\chapter{Grundlagen}

\section{JavaScript}

\subsection{Geschichte}

JavaScript wurde 1995 von Brendan Eich für den \emph{Netscape Navigator 2.0} entwickelt. Sie war auch
in allen darauf folgenden Versionen enthalten und wurde von Microsoft unter dem Namen \emph{JScript}
im \emph{Internet Explorer 3.0} implementiert.

Ab 1996 begann die Standardisierung der Sprache im Rahmen eines ECMA-Standards, welcher im Juni 1997
erschienen ist. Im April 1998 wurde dieser durch die ISO zum internationalen Standard \emph{ISO/IEC
16262} zugelassen.

Im Laufe der Jahre wurde der ECMAScript-Standard immer erweitert und beispielsweise Reguläre
Ausdrücke, Exception-Handling und verbesserte Stringfunktionen hinzugefügt. Die aktuelle Ausgabe 5.1
des ECMAScript-Standards entspricht dem internationalen Standard \emph{ISO/IEC 16262:2011}.
\citep[S. vii]{ecmascript}

Auch zum Zeitpunkt der Veröffentlichung dieser Arbeit wird der ECMAScript-Standard und damit die
Sprache JavaScript weiterentwickelt. Jeder moderne Browser unterstützt die Sprache, allerdings
nicht zwangsläufig alle Sprachelemente die in der aktuellsten Spezifikation enthalten sind.


\subsection{Anwendungsgebiete}

Der bekannteste und häufigste Verwendungszweck von JavaScript ist Web-Scripting innerhalb von
Browsern, was auch nicht weiter verwunderlich ist, da die Sprache ursprünlich für diesen Zweck
entwickelt wurde und lange Zeit ausschließlich in diesem Kontext benutzt wurde. Dabei stellt der
Webbrowser die Host-Umgebung, also die Objekte und Funktionen zu Kommunikation mit der Applikation,
in der die Scripts ausgeführt werden. Im Webbrowser sind solche Objekte beispielsweise das
Browserfenster (\lstinline{window}), Popupfenster (Rückgabewert von \lstinline{window.open()}),
die Browserhistory (\lstinline{history}), das aktuelle HTML-Dokument (\lstinline{document}).
Ebenfalls vom Browser bereitgestellt werden Objekte, die die einzelnen HTML-Elemente repräsentieren,
also beispielsweise Hpyerlinks, Formulare und Bilder. Darüberhinaus bietet der Browser Methoden, um
über verschiedene Ereignisse wie Klicks, Mausbewegungen und Änderungen an Formularfeldern
benachrichtigt zu werden.
\citep[S. 2]{ecmascript}

Ein weiteres Anwendungsgebiet ist \emph{Server-Side JavaScript} (\emph{SSJS}). Dabei wird JavaScript
direkt auf den (Web-)Server ausgeführt und kann beispielsweise direkt auf Datenbanken und Dateien
(des Servers) zugreifen. Während \emph{SSJS} erstmalig 1996 im \emph{Netscape Enterprise HTTP Server}
zum Einsatz kam, erlebte es erst fast 15 Jahre danach seinen Durchbruch. Mit
\emph{node.js}\footnote{\href{http://nodejs.org}{http://nodejs.org}} existiert ein quelloffenes,
plattformunabhängiges Framework welches leichtgewichtig ist und dank einer eventbasierten Architektur
auch bei einer sehr großen Anzahl gleichzeitiger Clientverbindungen noch performant ist - eine
Eigenschaft die in klassischen prozess- oder threadbasierten Webservern wie \emph{Apache} oftmals
nicht gegeben ist. Die serverseitige Host-Umgebung unterscheidet sich logischerweise stark von der
eines Browsers, da ein Webserver weder mit Fenstern noch HTML-Dokumenten arbeitet - dafür kennt er
beispielsweise HTTP-Requests und Formular\emph{daten}. Die Ereignisse, auf die Scripte reagieren
können, sind dabei primär netzwerkbezogen - beispielsweise die neue Verbindung eines Clients oder
der vorzeitige Abbruch eines Seitenaufrufs. Es ist allerdings durchaus möglich, dass mit
entsprechendem Code Teile der Browserumgebung serverseitig nachgebildet werden. So ist es denkbar,
ein HTML-Dokument nicht als String darzustellen sondern als DOM-Tree. Dieser könnte dann dieselben
Methoden wie der Browser zur Verfügung stellen, sodass Operationen die sowohl clientseitig als auch
serverseitig sinnvoll sind, denselben Code nutzen können.


\subsection{Programmierparadigmen}

Das Programmierparadigma einer Programmiersprache ist "die Sichtweise auf und den Umgang mit den zu
verarbeiteten Daten und Operationen". \citep[Kap. 1.3.1]{progsprachen}
In JavaScript kann man man sich zwischen drei dieser Paradigmen entscheiden:

\begin{description}
\item[Imperative/prozedurale Programmierung] \hfill \\
Bei der imperativen Programmierung wird eine Folge von Anweisungen sequentiell abgearbeitet. Zur
Kapselung und Wiederverwendung von Funktionalität werden Funktionen genutzt.
\citep[Kap. 1.3.1]{progsprachen}

Da die Host-Umgebung in JavaScript Objekte zur Verfügung stellt und auch Datentypen wie Strings und
Arrays Objekte sind, kann man jedoch nicht rein prozedural programmieren - man kann aber vollständig
auf die Nutzung eigener Objekte verzichten. Da dadurch viel Komfort wie die Nutzung assoziativer
Arrays - die in JavaScript simple Objekte sind - verloren geht ist dieses Paradigma nicht zu
empfehlen. Es kann aber durchaus sinnvoll sein, Funktionen außerhalb von Objekten zu definieren,
sofern sie alleinstehend sind und man keien Namespaces nutzen will: JavaScript unterstützt zwar
keine Namespace, allerdings sind Funktionen sog. \emph{First-Class-Objekte}, d.h. man kann sie in
Variablen speichern und sie haben noch weitere Eigenschaften, auf die später näher eingegangen
wird. Aufgrund der Möglichkeit, Funktionen in Variablen zu speichern, kann man Namespaces einfach
durch assoziative Arrays simulieren, indem man die Funktionen in solchen Arrays speichert und sie
daher nicht mehr im globalen Kontext liegen sondern nur über das Array aufrufbar sind.

\item[Objektbasierte Programmierung] \hfill \\
Eine objektbasierte Programmiersprache unterstützt Objekte, kennt im Gegensatz zu einer
objekt\emph{orientierten} Programmiersprache allerdings keine Klassen.
\citep[Kap. 1.3.1]{progsprachen}

Nachdem zuvor schon Objekte erwähnt wurden, die von der Host-Umgebung zur Verfügung gestellt werden,
ist es nur logisch, dass der Entwickler auch selbst Objekte definieren kann. Dies geschieht
allerdings anders als in klassischen objektorientierten Programmiersprachen wie Java oder C++ über
Klassen sondern über Objekte und Konstruktoren (die wiederum ganz normale Funktionen sind).
Da das Objektsystem von JavaScript einzigartig ist und einige Besonderheiten besitzt, wird im
Verlauf dieses Kapitels näher darauf eingegangen.

\item[Funktionale Programmierung] \hfill \\
Eine rein funktionales Programmiersprache basiert nicht auf Wertzuweisungen sondern benutzt
ausschließlich Funktionsdefinitionen, die eine Eingabe in eine Ausgabe transformieren.
\citep[Kap. 1.3.1]{progsprachen}

JavaScript ist allerdings nicht direkt eine funktionale Programmiersprache und damit erst recht
keine rein funktionale Programmiersprache. Dadurch, dass Funktionen \emph{First-Class-Objekte} sind
und sowohl anonyme Funktionen als auch Closures unterstützt werden, kann man in JavaScript sehr
einfach funktionale Elemente mit objektorientierten bzw. prozeduralen Elementen mischen. Die
prominentesten aus anderen funktionalen Programmiersprachen bekannten Methoden sind
\lstinline{forEach()} um eine Funktion alle Elemente einer Liste anzuwenden, \lstinline{map()} um
eine Liste mittels einer Funktion in eine neue Liste zu transformieren und \lstinline{filter()} um
nur die Elemente aus einer Liste zu übernehmen, die von der Filter-Funktion durch die Rückgabe vob
\lstinline{true} akzeptiert wurden.
\end{description}


\subsection{First-Class-Objekte}
In JavaScript handelt es sich bei Funktionen um sogenannte \emph{First-Class-Objekte}. Dies
bedeutet an sich nur, dass es sich bei Funktionen um Objekte handelt - beispielsweise kann eine
Funktion wie jedes andere Objekt Attribute und Methoden (die wiederum Funktionen sind) besitzen.
Details zu den verschiedenen Objekt-Typen einschließlich Funktionsobjekten finden sich in
\citep[S. 30ff]{ecmascript}.

\emph{First-Class} beschreibt Eigenschaften die man bei Objekten im Allgemeinen erwartet, im
Zusammenhang mit Funktionen allerdings durchaus ungewöhnlich sind:

\begin{itemize}
\item Sie können in Variablen und anderen Datenstrukturen (beispielsweise Arrays) gespeichert
werden.
\begin{lstlisting}[caption=Zuweisung einer Funktion an eine Variable]
var foo = someFunction;
\end{lstlisting}

\item Sie können Funktionsparameter sein.
\begin{lstlisting}[caption=Erstellen einer neuen Liste mittels einer Transformationsfunktion]
var roots = [4, 9, 16].map(Math.sqrt);
\end{lstlisting}

\item Sie können Rückgabewert einer Funktion sein.

\item Sie können zur Laufzeit erstellt werden.
\begin{lstlisting}[caption=Eine Funktion\, die eine neue Funktion erstellt und zurückgibt]
function makeFunction() {
    function newFunction() {}
    return newFunction;
}
\end{lstlisting}

\item Sie sind nicht an einen Namen gebunden.
\begin{lstlisting}[caption=Erstellen einer anonymen Funktion]
function makeFunction() {
    return function() {};
}
\end{lstlisting}
\end{itemize}


\subsection{Native Objekte}
Wie zuvor erwähnt sind beispielsweise Strings und Arrays Objekte. Diese sind jedoch nicht in
JavaScript selbst implementiert sondern in der Sprache der JavaScript-Engine, also beispielsweise C
oder C++. Ihr Verhalten ist durch die ECMAScript-Spezifikation \citep{ecmascript} vollständig
definiert. Dies bedeutet beispielsweise dass es prinzipiell sicher ist, gewisse Operationen mit
diesen Objekten auszuführen - beispielsweise sie um eigene Methoden zu erweitern. Sofern ein natives
Objekt eine Operation nicht unterstützt wird eine entsprechende Fehlermeldung ausgegeben.



\subsection{Host-Objekte}

Bei Host-Objekten handelt es sich um von der Host-Umgebung zur Verfügung gestellte Objekte die in
der Regel nicht in JavaScript sondern in der Sprache der Host-Umgebung oder der JavaScript-Engine
geschrieben sind. Diese Objekte sind auf die Umgebung zugeschnitten in der das Script läuft - im
Browser werden beispielsweise die DOM-Elemente durch Host-Objekte repräsentiert.
Während native Objekte durch die ECMAScript-Spezifikation definiert sind, gibt es für Host-Objekte
lediglich einige Anforderungen und Einschränkungen, die notwendig sind, damit die JavaScript-Engine
korrekt mit ihnen arbeiten und die Codeausführung optimieren kann: Alle internen Objekteigenschaften
müssen definiert und gewisse Invarianten erfüllt sein.

Das Verhalten dieser Objekte ist jedoch nicht
spezifiziert: \enquote{Host objects may implement these internal methods in any manner unless specified
otherwise} \citep[S. 33]{ecmascript}; die \enquote{internal methods} sind beispielsweise die Getter
und Setter von Objekteigenschaften. Darüberhinaus dürfen auch die Auswirkungen von internen
Eigenschaften erweitert werden: \enquote{Host objects may support these internal properties with any
implementation-dependent behaviour as long as it is consistent with the specific host object
restrictions stated in this document.} \citep[S. 31]{ecmascript}

Ein Beispiel für das undefinierte Verhalten von Host-Objekten findet sich im
Blog\footnote{\href{http://perfectionkills.com/whats-wrong-with-extending-the-dom}{http://perfectionkills.com/whats-wrong-with-extending-the-dom}}
eines ehemaligen Entwicklers eines JavaScript-Frameworks, welches im dritten Kapitel noch näher
betrachtet wird:

\begin{lstlisting}[caption=Verhalten von Host-Objekten im Internet Explorer]
document.createElement('p').offsetParent; // "Unspecified error."
new ActiveXObject("MSXML2.XMLHTTP").send; // "Object doesn't support this property or method"
\end{lstlisting}

In diesem Beispiel wird auf nicht vorhandene Eigenschaften bzw. Methoden von zwei verschiedenen
Host-Objekten lesend zugegriffen. Native und benutzerdefinierte Objekte würden in diesem Fall
einfach \lstinline{undefined} zurückgeben statt eine Exception auszulösen.
Es ist auch durchaus möglich, dass eine Wertzuweisung keine Fehlermeldung bzw. Exception auslöst,
jedoch stillschweigend ignoriert wird und die Eigenschaft des betroffenen Objekts ihren alten Wert
beibehält.


\subsection(Closures)
Normalerweise unterscheidet man in der Programmierung zwischen lokalen Variablen, die nur innerhalb
einer Funktion sichtbar und lebendig sind, globalen Variablen, die überall sichtbar sind und Membervariablen, die
nur über ein Objekt sichtbar sind. Wenn keine Funktionen zur Laufzeit definiert werden, reichen
diese Variablentypen auch aus. Wenn man jedoch Funktionen zur Laufzeit definiert, besteht die
Möglichkeit, dass dies in einer Funktion geschieht, die bereits lokale Variablen besitzt. In der
inneren Funktion sind diese Variablen nun ebenfalls verfügbar. Daher dürfen sie vom Garbage
Collector nicht gelöscht werden obwohl es funktions-lokale Variablen sind und die Funktion, in der
sie definiert wurden, bereits verlassen wurde. Die Kombination aus einer Funktion und ihrer Umgebung
(also den außerhalb definierten Variablen) bezeichnet man als \emph{Closure}. Die innerhalb der
Funktion verfügbaren Variablen, die weder lokal noch global sind, bezeichnet man als
\emph{nichtlokale} Variablen.

Im folgenden Beispiel wird eine Closure genutzt, um eine Funktion zu erstellen, die eine Variable in
ihrer Nutzung insofern einschränkt, dass sie nicht direkt gelesen oder geschrieben werden kann
sondern nur mittels der zurückgegebenen Funktion ausgelesen werden kann, wobei ihr Wert sich bei
jedem dieser Vorgänge um \lstinline{1} erhöht.

\begin{lstlisting}[caption=Beispiel für eine Closure]
function makeIncrementer(val) {
    return function() {
        return ++val;
    }
}
\end{lstlisting}

Eine mögliche Nutzung von Closures ist also die Kapselung von Variablen; ein weiterer
Anwendungsbereich wird später zusammen mit dem Objektmodell von JavaScript vorgestellt.
