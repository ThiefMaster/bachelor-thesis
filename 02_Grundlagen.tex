\chapter{Grundlagen}

\section{JavaScript}

\subsection{Geschichte}

JavaScript wurde 1995 von Brendan Eich für den \emph{Netscape Navigator 2.0} entwickelt. Sie war auch
in allen darauf folgenden Versionen enthalten und wurde von Microsoft unter dem Namen \emph{JScript}
im \emph{Internet Explorer 3.0} implementiert.

Ab 1996 begann die Standardisierung der Sprache im Rahmen eines ECMA-Standards, welcher im Juni 1997
erschienen ist. Im April 1998 wurde dieser durch die ISO zum internationalen Standard \emph{ISO/IEC
16262} zugelassen.

Im Laufe der Jahre wurde der ECMAScript-Standard immer erweitert und beispielsweise Reguläre
Ausdrücke, Exception-Handling und verbesserte Stringfunktionen hinzugefügt. Die aktuelle Ausgabe 5.1
des ECMAScript-Standards entspricht dem internationalen Standard \emph{ISO/IEC 16262:2011}.
\citep[S. vii]{ecmascript}

Auch zum Zeitpunkt der Veröffentlichung dieser Arbeit wird der ECMAScript-Standard und damit die
Sprache JavaScript weiterentwickelt. Jeder moderne Browser unterstützt die Sprache, allerdings
nicht zwangsläufig alle Sprachelemente die in der aktuellsten Spezifikation enthalten sind.


\subsection{Anwendungsgebiete}

Der bekannteste und häufigste Verwendungszweck von JavaScript ist Web-Scripting innerhalb von
Browsern, was auch nicht weiter verwunderlich ist, da die Sprache ursprünlich für diesen Zweck
entwickelt wurde und lange Zeit ausschließlich in diesem Kontext benutzt wurde. Dabei stellt der
Webbrowser die Host-Umgebung, also die Objekte und Funktionen zu Kommunikation mit der Applikation,
in der die Scripts ausgeführt werden. Im Webbrowser sind solche Objekte beispielsweise das
Browserfenster (\lstinline{window}), Popupfenster (Rückgabewert von \lstinline{window.open()}),
die Browserhistory (\lstinline{history}), das aktuelle HTML-Dokument (\lstinline{document}).
Ebenfalls vom Browser bereitgestellt werden Objekte, die die einzelnen HTML-Elemente repräsentieren,
also beispielsweise Hpyerlinks, Formulare und Bilder. Darüberhinaus bietet der Browser Methoden, um
über verschiedene Ereignisse wie Klicks, Mausbewegungen und Änderungen an Formularfeldern
benachrichtigt zu werden.
\citep[S. 2]{ecmascript}

Ein weiteres Anwendungsgebiet ist \emph{Server-Side JavaScript} (\emph{SSJS}). Dabei wird JavaScript
direkt auf den (Web-)Server ausgeführt und kann beispielsweise direkt auf Datenbanken und Dateien
(des Servers) zugreifen. Während \emph{SSJS} erstmalig 1996 im \emph{Netscape Enterprise HTTP Server}
zum Einsatz kam, erlebte es erst fast 15 Jahre danach seinen Durchbruch. Mit
\emph{node.js}\footnote{\href{http://nodejs.org}{http://nodejs.org}} existiert ein quelloffenes,
plattformunabhängiges Framework welches leichtgewichtig ist und dank einer eventbasierten Architektur
auch bei einer sehr großen Anzahl gleichzeitiger Clientverbindungen noch performant ist - eine
Eigenschaft die in klassischen prozess- oder threadbasierten Webservern wie \emph{Apache} oftmals
nicht gegeben ist. Die serverseitige Host-Umgebung unterscheidet sich logischerweise stark von der
eines Browsers, da ein Webserver weder mit Fenstern noch HTML-Dokumenten arbeitet - dafür kennt er
beispielsweise HTTP-Requests und Formular\emph{daten}. Die Ereignisse, auf die Scripte reagieren
können, sind dabei primär netzwerkbezogen - beispielsweise die neue Verbindung eines Clients oder
der vorzeitige Abbruch eines Seitenaufrufs. Es ist allerdings durchaus möglich, dass mit
entsprechendem Code Teile der Browserumgebung serverseitig nachgebildet werden. So ist es denkbar,
ein HTML-Dokument nicht als String darzustellen sondern als DOM-Tree. Dieser könnte dann dieselben
Methoden wie der Browser zur Verfügung stellen, sodass Operationen die sowohl clientseitig als auch
serverseitig sinnvoll sind, denselben Code nutzen können.


\subsection{Programmierparadigmen}

Das Programmierparadigma einer Programmiersprache ist "die Sichtweise auf und den Umgang mit den zu
verarbeiteten Daten und Operationen". \citep[Kap. 1.3.1]{progsprachen}
In JavaScript kann man man sich zwischen drei dieser Paradigmen entscheiden:

\begin{description}
\item[Imperative/prozedurale Programmierung] \hfill \\
Bei der imperativen Programmierung wird eine Folge von Anweisungen sequentiell abgearbeitet. Zur
Kapselung und Wiederverwendung von Funktionalität werden Funktionen genutzt.
\citep[Kap. 1.3.1]{progsprachen}

Da die Host-Umgebung in JavaScript Objekte zur Verfügung stellt und auch Datentypen wie Strings und
Arrays Objekte sind, kann man jedoch nicht rein prozedural programmieren - man kann aber vollständig
auf die Nutzung eigener Objekte verzichten. Da dadurch viel Komfort wie die Nutzung assoziativer
Arrays - die in JavaScript simple Objekte sind - verloren geht ist dieses Paradigma nicht zu
empfehlen. Es kann aber durchaus sinnvoll sein, Funktionen außerhalb von Objekten zu definieren,
sofern sie alleinstehend sind und man keien Namespaces nutzen will: JavaScript unterstützt zwar
keine Namespace, allerdings sind Funktionen sog. \emph{First-Class Objects}, d.h. man kann sie in
Variablen speichern und sie haben noch weitere Eigenschaften, auf die später näher eingegangen
wird. Aufgrund der Möglichkeit, Funktionen in Variablen zu speichern, kann man Namespaces einfach
durch assoziative Arrays simulieren, indem man die Funktionen in solchen Arrays speichert und sie
daher nicht mehr im globalen Kontext liegen sondern nur über das Array aufrufbar sind.

\item[Objektbasierte Programmierung] \hfill \\
Eine objektbasierte Programmiersprache unterstützt Objekte, kennt im Gegensatz zu einer
objekt\emph{orientierten} Programmiersprache allerdings keine Klassen.
\citep[Kap. 1.3.1]{progsprachen}

Nachdem zuvor schon Objekte erwähnt wurden, die von der Host-Umgebung zur Verfügung gestellt werden,
ist es nur logisch, dass der Entwickler auch selbst Objekte definieren kann. Dies geschieht
allerdings anders als in klassischen objektorientierten Programmiersprachen wie Java oder C++ über
Klassen sondern über Objekte und Konstruktoren (die wiederum ganz normale Funktionen sind).
Da das Objektsystem von JavaScript einzigartig ist und einige Besonderheiten besitzt, wird im
Verlauf dieses Kapitels näher darauf eingegangen.

\item[Funktionale Programmierung] \hfill \\
Eine rein funktionales Programmiersprache basiert nicht auf Wertzuweisungen sondern benutzt
ausschließlich Funktionsdefinitionen, die eine Eingabe in eine Ausgabe transformieren.
\citep[Kap. 1.3.1]{progsprachen}

JavaScript ist allerdings nicht direkt eine funktionale Programmiersprache und damit erst recht
keine rein funktionale Programmiersprache. Dadurch, dass Funktionen \emph{First-Class Objects} sind
und sowohl anonyme Funktionen als auch Closures unterstützt werden, kann man in JavaScript sehr
einfach funktionale Elemente mit objektorientierten bzw. prozeduralen Elementen mischen. Die
prominentesten aus anderen funktionalen Programmiersprachen bekannten Methoden sind
\lstinline{forEach(list, func)} um die Funktion \lstinline{func} auf alle Elemente von
\lstinline{list} anzuwenden, \lstinline{map(list, func)} um eine Liste mittels einer Funktion in
eine neue Liste zu transformieren und \lstinline{filter(list, func)} um nur die Elemente aus
einer Liste zu übernehmen, die von der Funktion durch die Rückgabe von \lstinline{true} akzeptiert
wurden.
\end{description}

\subsection{First-Class-Objects}
\todotext{Zeugs zu first-class Objekten}
