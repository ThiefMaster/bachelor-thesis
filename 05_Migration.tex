\chapter{Migration zu Query}

Bei der (teilweisen) Migration zu jQuery sind einige Schritte am Anfang zwingend notwendig, während
andere optional sind und in relativ beliebiger Reihenfolge ausgeführt werden können. Im Folgenden
werden die Migrationsschritte in der Reihenfolge beschrieben, wie sie durchgeführt wurden.

\section{Vorbereitung}

In der Vorbereitungsphase wird jQuery eingebunden und dabei auftretende Konflikte behoben. Es findet
zu diesem Zeitpunkt noch keine Migration statt.

\subsection{Einbinden von jQuery}

Um JavaScript-Dateien in Indico einzubinden fügt man nicht wie üblich
\lstinline[language=HTML]{<script>}-Tags in einem HTML-Template ein sondern erweitert die Funktion
\lstinline{getJSFiles()} der Basisklasse für HTML-Seiten \lstinline{WPBase} sodass sie die
notwendigen Dateien einbindet. Im Falle von jQuery, wo neben jQuery selbst auch jQuery UI und später
diverse Plugins eingebunden werden müssen, bietet sich eine separate Funktion an. Da Indico im
Produktivmodus einzelne JavaScript-Dateien zu komprimierten Paketen \enquote{kompiliert}, muss
zusätzlich zur Python-Funktion die Konfigurationsdatei von \emph{jsmin} angepasst werden, damit die
neuen Dateien in einem solchen Paket zusammengefasst werden.

\begin{lstlisting}[language=Python,caption=Einbinden von jQuery und Underscore.js in Indico]
def _includeJQuery(self):
    info = HelperMaKaCInfo().getMaKaCInfoInstance()
    files = ['underscore', 'jquery', 'jquery-ui']
    if info.isDebugActive():
        return ['js/jquery/%s.js' % f for f in files]
    else:
        return ['js/jquery/jquery.js.pack']
\end{lstlisting}

\subsection{Beheben von Konflikten}

Nachdem jQuery und Underscore.js nun eingebunden sind, muss überprüft werden, ob es Konflikte gibt.
Diese gibt es durch das gleichzeitige Vorhandensein von jQuery und Prototype in der Tat - unabhängig
davon, dass dieser Konflikt bereits aus der Analysephase bekannt ist, zeigt er sich auf Seiten, die
Prototype nutzen - auf diesen funktionieren die JavaScripts nicht mehr korrekt. Der Konflikt
entsteht dadurch, dass jQuery und Prototype beide \lstinline{$} für sich beanspruchen und daher das
zuletzt eingebundene Framework die vorherige Variable überschreibt. Da jQuery nach Prototype
eingebunden wird, ist dieses Problem einfach zu lösen - mittels
\lstinline{var $j = jQuery.noConflict();} wird die Prototype-Funktion wiederhergestellt und jQuery
via \lstinline{$j} verfügbar gemacht. Dabei handelt es sich allerdings um eine temporäre Lösung um
Prototype so lange beizubehalten, bis der darauf basierende Code vollständig migriert wurde. Sie hat
den Vorteil, dass der Prototype-Code teilweise zeilenweise migriert werden und währenddessen immer
wieder auf korrekte Funktion geprüft werden kann.

\subsection{Migration von Prototype-basiertem Code}

Einige Bereiche des \emph{Room Booking}-Systems von Indico nutzen Prototype zum Registrieren von
Events. Darüberhinaus wird Prototype dort zur Formularvalidierung genutzt: Mithilfe des Objekts
\lstinline{Form.Observer} werden die Formulare alle 400ms auf Änderungen überprüft und wenn nötig
erneut validiert. Die häufige Prüfung auf Änderungen ist weder effizient noch notwendig -
Formularelemente können über die \lstinline{change}-, \lstinline{click}- und
\lstinline{keyup}-Events bei jeder Änderung validiert werden ohne mehrmals pro Sekunde alle
Formularelemente auf Änderungen zu überprüfen. Um den Validierungscode mit jQuery möglichst
effizient zu machen werden die Events nicht für alle Formularelemente registriert sondern nur für
das Formular selbst, wobei ein \emph{Delegate} genutzt wird, um speziell auf Events der enthaltenen
Formularelemente zu reagieren. \autoref{lst:jquery-validation-events} zeigt die Registrierung der
Events; im \emph{submit}-Event wird das Formular erneut validiert und, sofern es nicht gültig ist,
das Abschicken des Formulars verhindert und eine Fehlermeldung ausgegeben.

\begin{lstlisting}[caption=Formularvalidierung via jQuery,label=lst:jquery-validation-events]
$j('#bookingForm').delegate(':input', 'keyup change', function() {
    forms_are_valid();
}).submit(function(e) {
    if (!forms_are_valid(true)) {
        e.preventDefault();
        alert($T('There are errors in the form. Please correct the fields with red background.'));
    };
});
\end{lstlisting}

Ebenfalls Änderungsbedarf besteht bei den in \autoref{lst:rb-inline-events} verwendeten
Inline-Eventhandlern. Da die betroffenen Formularelemente bereits IDs besitzen kann ihnen über
jQuery mühelos ein Eventhandler zugewiesen werden - dadurch können alle Scripts an derselben Stelle
im HTML-Code stehen, was den Code lesbarer macht; unabhängig davon muss der Code geändert werden, da
die dort verwendete \lstinline{$}-Funktion aus Prototype stammt.

\begin{lstlisting}[language=HTML,label=lst:rb-inline-events,caption=Inline-Eventhandler]
<input id="onlyBookings" type="checkbox" onchange="if (this.checked) $('onlyPrebookings').checked = false;"/>
<input id="onlyPrebookings" type="checkbox" onchange="if (this.checked) $('onlyBookings').checked = false;" />
\end{lstlisting}

An vielen Stellen zahlt es sich aus, dass Prototype und jQuery gewisse Ähnlichkeiten besitzen;
\autoref{lst:prototype-jquery-diff} zeigt die Änderungen eines von Prototype zu jQuery migrierten
Codeblocks.

\begin{lstlisting}[language=diff,label=lst:prototype-jquery-diff,caption=Ähnlichkeit zwischen jQuery und Prototype]
- $('blockedRooms').setValue(Json.write(roomGuids));
+ $j('#blockedRooms').val(Json.write(roomGuids));
\end{lstlisting}

Neben dem \emph{Room Booking}-System verwendet auch der \emph{Badge Editor}, ein Tool zum Erstellen
von Namensschildern für Konferenzen, Prototype. Dort wird es primär zur Unterstützung von Drag\&Drop
eingesetzt.

\img{indico-badge-editor.png}{400px}{Der Indico Badge Editor}{Indico Badge Editor}

Nebem dem Migrieren des Prototype/Scriptaculous-basierten Drag\&Drop-Systems bietet sich dort eine
vollständige Migration an, da zum einen eine Mischung aus Indico- und Prototype-Code benutzt wird
und zum anderen selbiger Code ausschließlich DOM-Operationen ausführt. Wie auch auf dem \emph{Room
Booking}-Seiten bietet sich auch hier an, ungültigen und unsauberen Code zu korrigieren bzw.
aufzupolieren. In diesem Fall beinhaltet dies die Benutzung korrekter IDs - Leerzeichen sind dort
nicht zulässig - und das Entfernen von Inline-Eventhandlern. Die Uploadfunktion für
Hintergrundbilder erstellt einen IFrame, um das Uploadformular dorthin abzusenden, sodass die Seite
selbst nicht neugeladen werden muss. Für diese unsaubere Methode bieten sich zwei Lösungen an: Durch
die Integration des \emph{jQuery Form}-Plugins ließe sich der IFrame-Code in jQuery-Plugin
auslagern, sodass der Code übersichtlicher gehalten wird und gleichzeitig die Kompatibilität mit
allen Browsern bestehen bleibt. Sofern letzteres nicht notwendig wäre, könnte man auch die Fähigkeit
moderner Browser nutzen, über AJAX Dateien hochzuladen - aufgrund der Zielgruppe von Indico ist dies
jedoch nicht praktikabel. Da in der aktuellen Phase jedoch das Ziel Prototype zu entfernen im
Vordergrund steht und das Form-Plugin auch noch nicht eingebunden ist, bleibt der IFrame-Code
zunächst erhalten.

An dieser Stelle sind alle anhand der \lstinline{$}-Funktion leicht aufzufindenden Codestellen, die
Prototype nutzen, angepasst. Durch die Erweiterung der Prototypen nativer Objekte gibt es allerdings
noch Prototype-Funktionen, die nicht über \lstinline{$} oder eine der globalen Prototype-Klassen
gefunden werden können. Um diese zu finden könnte man entweder eine Liste aller in Prototype
enthaltenen Methoden erstellen und danach suchen oder aber nach der Entfernung von Prototype testen,
wo es Probleme gibt. Da Prototype nur auf relativ wenigen Seiten eingebunden wird, bietet sich
letztere Methode aufgrund des geringeren Aufwands an, obwohl dabei nicht sichergestellt ist, dass
alle Problemstellen gefunden werden - dazu wäre parallel dazu eine \emph{Code Coverage}-Analyte
notwendig, die sich jedoch ausschließlich auf die Codeteile erstrecken dürfte, die möglicherweise
Prototype nutzen, da ansonsten mangels automatischer Tests möglichst alle JavaScripts in Indico
manuell ausgeführt werden müssten, obwohl ein großer Teil garnicht in der Lage ist, Prototype zu
nutzen.

\subsection{Entfernen von Prototype}

Ähnlich wie beim Einbinden von jQuery muss auch beim Entfernen von Prototype die Methode
\lstinline{getJSFiles()} modifiziert werden. Da Prototype nicht global integriert ist, überschreiben
verschiedene Unterklassen von \lstinline{WPBase} diese Methode - sofern dies ausschließlich der
Integration von Prototype dient, kann die Methode einfach entfernt werden; falls weitere JavaScripts
eingebunden werden, muss die Methode entsprechend angepasst werden.

Die im letzten Abschnitt erwähnten Tests zeigen, dass außer einer undefinierten Funktion
\lstinline{size()} keine Probleme auftreten. Bei der Funktion handelt es sich um eine generische
Funktion um die Anzahl der Elemente in einem \emph{Enumerable}-Objekt - also einem Array, einem
Objekt oder einer Argumentliste - zu bestimmen. Während JavaScript bei Arrays über die
\lstinline{length}-Eigenschaft direkten Zugriff auf die Anzahl der Elemente bietet, existiert eine
solche Eigenschaft bei Objekten nicht. Dies ergibt insofern Sinn, dass es zwei Möglichkeiten gibt,
die Anzahl zu bestimmen: Zum einen könnte man ausschließlich die Eigenschaften zählen, die das
Objekt selbst besitzt, zum anderen könnte man auch alle über die Prototypenkette erreichbaren
Eigenschaften mitzählen. Da Underscore.js mit \lstinline{_.size()} eine solche Funktion enthält,
kann \lstinline{someObject.size()} einfach durch \lstinline{_.size(someObject)} ersetzt werden.

Zusammen mit Prototype kann auch die \lstinline{$j}-Kompatibilitätsschicht entfernt werden, da
\lstinline{$} nun unbenutzt ist. Dazu wird der Aufruf von \lstinline{jQuery.noConflict} entfernt und
per dateiübergreifendem \emph{Suchen\&Ersetzen} jedes Vorkommen von \lstinline{$j} durch
\lstinline{$} ersetzt.

\section{Migration}

\subsection{Entwicklung des DateRange-Widgets}

Das \emph{Room Booking}-Modul von Indico ermöglicht es bestimmten Personen, Konferenzzimmer über
eine gewisse Zeit zu blockieren, sodass diese nur von ausgewählten Gruppen reserviert werden können.
Beim Erstellen einer solchen Blockade müssen sowohl Start- als auch Enddatum ausgewählt werden.
Dazu werden zwei Textfelder benutzt, die jeweils beim Klick auf den nebenstehenden Button einen
Kalender zur Auswahl des Datums öffnen. Diese Datumsfelder werden durch ein Indico-Widget erstellt.
Komfortabler wäre es allerdings, statt der Textfelder dauerhaft zwei Kalender anzuzeigen. Da das von
Indico verwendete Kalender-Widget mehrere gleichzeitig sichtbare Kalender nicht unterstützt und es
von Vorteil wäre, kein separates \emph{Third-Party}-Script für den Kalender zu bnötigen, bietet es
sich hier an, den \emph{DatePicker} von jQuery UI zu nutzen.

\subsubsection{Funktionsanalyse des Datepickers}

Der Datepicker wird in der Regel mit einem Textfeld verknüpft, sodass er sich beim Fokussieren des
Felds automatisch öffnet und nach Auswahl eines Datums wieder schließt. Es ist allerdings auch
möglich, ihn mit einem \lstinline[language=HTML]{<div>} zu verknüpfen. In diesem Fall ist er
dauerhaft sichtbar und stellt das ausgewählte Datum lediglich über seine API zur Verfügung. Viele
Eigenschaften des Datepickers können individuell konfiguriert werden; insbesondere ist es möglich,
Daten in der Vergangenheit bzw. vor oder nach einem bestimmten Datum zum sperren und die
auswählbaren Jahre zu beschränken. Das Widget bietet auch eine Option, um mehrere Monate
gleichzeitig anzuzeigen. Hierbei sind allerdings nur mehrere aufeinanderfolgende Monate möglich und
es kann unabhängig von der Anzahl der angezeigten Monate nur ein Datum ausgewählt werden. Daher muss
das DateRange-Widget zwei separate DatePicker nutzen.

\subsubsection{Anforderungen}

Das DateRange-Widget soll zwei DatePicker nebeneinander anzeigen und ausschließlich die Auswahl
gültiger Daten zulassen. Die ausgewählten Daten sollen optional in versteckten Formularfeldern
gespeichert werden, sodass sie beim Absenden des zugehörigen Formulars mitgesendet werden. Es soll
möglich sein, bereits beim Erstellen des Widgets ein Start- und Enddatum anzugeben welches
standardmäßig ausgewählt ist. Das Datum soll über die DatePicker jeweils änderbar sein, sofern das
Widget nicht deaktiviert ist. Um den Benutzerkomfort zu erhöhen soll jedes gültige Datum auswählbar
sein, sodass (sofern Jahr und Monat bereits ausgewählt sind) es immer möglich ist, mit zwei Klicks
die gewünschten Daten auszuwählen. Es soll eine Option geben, um die Auswahl von Daten in der
Vergangenheit zu verhindern - um das Widget so allgemein wie möglich zu halten, soll es allerdings
möglich sein, beliebige Datepicker-Optionen zu verändern - sowohl für beide Datepicker als auch nur
für einzelne.

\subsubsection{Implementierung}

Da es das DateRange-Widget vollständig auf jQuery basieren soll und keinerlei Funktionen aus dem
alten Indico-Framework benötigt, bietet es sich an, es als \emph{UI Widget} zu realisieren. Dabei
handelt es sich um eine Sammlung von Funktionen, die über eine einzelne jQuery-Funktion zugänglich
gemacht werden, und verschiedene Basisfunktionen standardmäßig enthalten. Innerhalb der Funktionen
eines Widgets zeigt \lstinline{this} auf das Widget-Objekt und \lstinline{this.element} enthält das
jQuery-Element, in welchem das Widget erstellt wurde - wenn ein Widget über ein jQuery-Objekt
erstellt wird, welches mehrere Elemente enthält werden separate Widgets erstellt, sodass
\lstinline{this.element} immer exakt ein Element enthält. Einzelne Funktionen im Widget werden durch
jQuery automatisch aufgerufen; beispielsweise wird \lstinline{_init()} bei jedem Aufruf der
Widgetfunktion ausgeführt und \lstinline{_create()} ausgeführt, wenn die Widgetfunktion ein neues
Widget erstellt.

Im DateRange-Widget wird die \lstinline{_create}-Funktion genutzt, um die Datepicker zu erstellen
und zu konfigurieren. Sofern versteckte Formularfelder verwendet werden sollen, werden sie ebenfalls
in dieser Funktion erstellt. Um die geforderte Flexibilität bei der Konfiguration der einzelnen
Datepicker zu erreichen, wird die Methode \lstinline{$.extend()} von jQuery genutzt. Sie erweitert
das erste übergebene Objekt mit den Eigenschaften der übrigen Objekte, wobei bereits vorhandene
Eigenschaften überschrieben werden. Wie in \autoref{lst:daterange-picker-cfg} zu sehen ist, wird als
erstes das frühstmögliche Datum festgelegt. Da es unabhängig von \lstinline{allowPast} möglich sein
soll, ein anderes frühestes Datum vorzugeben, werden die zusätzlichen Datepicker-Optionen erst
danach festgelegt, sodass sie \lstinline{minDate} überschreiben können. Zuletzt werden die Optionen
für das Standarddatum und das versteckte Formularfeld übergeben. Diese können nicht überschrieben
werden, da beide durch die API des DateRange-Widgets ausreichend konfigurierbar sind.

\begin{lstlisting}[label=lst:daterange-picker-cfg,caption=Datepicker-Konfiguration im DateRange-Widget]
self.startPicker.datepicker($.extend({
    minDate: self.options.allowPast ? null : 0
}, self.options.pickerOptions, self.options.startPickerOptions, {
    altField: self.startDateField || '',
    defaultDate: self.options.startDate
}));
\end{lstlisting}

Um ungültige Daten zu verhindern, wird ein Eventhandler für die \emph{onSelect}-Events der beiden
Datepicker registriert. In diesem wird im Falle eines ungültigen Datums, d.h.
\lstinline{startDate > endDate}, das Datum des Datepickers, der gerade nicht verändert wurde, auf
das des anderen Datepickers gesetzt. Eine andere Möglichkeit wäre in diesem Eventhandler jeweils
\lstinline{minDate} und \lstinline{maxDate} des anderen Datepickers anzupassen, sodass
ausschließlich gültige Daten ausgewählt werden können. Dies würde jedoch den Benutzerkomfort
verringern, da ein an sich gültiges Datum in diesem Fall möglicherweise nicht auswählbar ist ohne
zuvor das andere Datum anzupassen.

\img{indico-daterange.png}{400px}{Das jQuery-basierte DateRange-Widget}{Indico DateRange Widget}
