\chapter{JavaScript-Frameworks}

\section{Vergleichskriterien}
Um die Frameworks miteinander vergleichen zu können, müssen einige Kriterien festgelegt werden,
anhand derer sich alle Frameworks messen lassen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
JavaScript-Frameworks kapseln den Zugriff auf Elemente in der Regel über Funktionen, die ein oder
mehrere Elemente anhand eines CSS-Selektors suchen und zurückgeben. Dabei können neben den nativ
implementierten CSS-Selektoren auch weitere Selektoren unterstützt werden.

\item[DOM-Manipulation] \hfill \\
Häufig möchte man mit JavaScript neue HTML-Elemente erstellen oder vorhandene Elemente verändern.
Dabei kann das Framework den Entwickler unterstützen, indem es beispielsweise das Verknüpfen von
Elementen und die Veränderung von CSS-Attributen vereinfacht.

\item[DOM Traversal] \hfill \\
Unter \emph{DOM Traversal} versteht man das Navigieren durch den DOM-Tree ausgehend von einem
bestimmten Element. Dabei gibt es sowohl einige Standardfunktionen die man in jedem Framework
erwarten kann als auch Komfortfunktionen.

\item[Events] \hfill \\
Wie bereits in \autoref{js-events} gezeigt unterscheiden sich die Eventsysteme der Browser
teilweise. Daher ist dies ein Bereich wo ein Framework sowohl die Browserunterschiede verbergen als
auch den Komfort erhöhen sollte.

\item[Objektsystem] \hfill \\
Manche JavaScript-Frameworks bringen ein eigenes Objektsystem mit, sodass die Arbeit mit Prototypen
und Konstruktoren vereinfacht wird und beispielsweise Mixin-Objekte unterstützt werden oder der
Aufruf einer überschriebenen Method der Parent-Klasse komfortabel möglich ist.

\item[Hilfsfunktionen] \hfill \\
Die meisten JavaScript-Frameworks bieten neben der bereits genannten Funktionalität weitere
Funktionen, die oftmals einen funktionalen Programmierstil vereinfachen oder komfortabler machen.
Allerdings sind nicht nur die funktionalen Funktionen sondern auch jegliche anderen Hilfsfunktionen
betrachtenswert.

\item[UI-Elemente] \hfill \\
Einige JavaScript-Frameworks enthalten UI-Elemente, um beispielsweise Dialoge oder Buttons zu
erzeugen. Die Frameworks unterscheiden sich dort sowohl im Umfang als auch in der Anpassbarkeit.

\item[Kompatibilität] \hfill \\
Bei der Integration in Indico ist es von Vorteil, wenn das Framework möglichst wenig Potenzial
besitzt, Konflikte zu verursachen. Dies kann durch verschiedene Ansätze erreicht werden.

\item[Sonstige Features] \hfill \\
Viele JavaScript-Frameworks haben neben den üblichen Features zusätzliche Funktionen, die in anderen
Frameworks nicht vorhanden sind.

\item[Performance] \hfill \\
Die unterschiedlichen Frameworks sind bei verschiedenen Operationen wie beispielsweise dem Zugriff
auf Elemente anhand eines CSS-Selektors unterschiedlich schnell. Allerdings spielt die Performance
im Rahmen dieser Arbeit nur eine untergeordnete Rolle, da Indico nirgends extrem viele Aktionen auf
einmal ausführt und Performanceunterschiede somit - auch dank den immer schnelleren
JavaScript-Engines - für den Endbenutzer nicht spürbar sind.

\item[Dokumentation] \hfill \\
Da mehrere Entwickler mit dem Framework arbeiten müssen und starke Fluktuation herrscht, da oftmals
Studenten für 3 bis 12 Monate an Indico arbeiten, ist eine gute Dokumentation wichtig, da es nicht
produktiv ist, wenn man erst den Quellcode des Frameworks lesen und verstehen muss um es benutzen zu
können. Insbesondere ist eine Dokumentation hilfreich, wenn sie für alle Funktionen des Frameworks
Beispielcode enthält.

\item[Lizenz] \hfill \\
Die meisten Frameworks sind unter einer OpenSource-Lizenz verfügbar.
Da Indico unter der
GNU~GPL\footnote{\href{http://www.gnu.org/licenses/gpl-2.0.txt}{http://www.gnu.org/licenses/gpl-2.0.txt}}
steht ist auf Kompatibilität mit dieser Lizenz zu achten. \autoref{img.floss-license-slide.png}
bietet einen kurzen Überblick über die verbreitetsten Open Source-Lizenzen und zeigt die
Kompatibilität: \enquote{To see if software can be combined, just start at their respective
licenses, and find a common box you can reach following the arrows.} \citep{osslic} \\
Da Indico unter der GPLv2+, d.h. \enquote{either version 2 of the License, or (at your option) any
later version}, lizenziert ist, sind alle Open Source-Lizenzen außer der \emph{Affero
GPL}\footnote{GPL mit der Erweiterung, dass auch bei einem Netzwerkzugriff auf das laufende Programm
eine \enquote{Verbreitung} stattfindet und der Quellcode zugänglich gemacht werden muss.}
kompatibel.
\img{floss-license-slide.png}{400px}{Kompatibilitätsdiagramm der verschiedenen Open
Source-Lizenzen \citep{osslic}}{OpenSource-Lizenz-Kompatibilität}
\end{description}



\section{Indico}
Das derzeit in Indico verwendet Framework besteht aus einem Loader-Script und ca. 50
JavaScript-Dateien, die das eigentliche Framework enthalten. In den HTML-Seiten von Indico wird das
Loader-Script jedoch nur im Entwicklungsmodus eingebunden; auf dem Produktivsystem werden die
einzelnen JavaScript-Dateien in einer einzelnen Datei zusammengefasst und komprimiert.

Das Framework ist in mehrere Module aufgeteilt. Im \emph{Core} werden Interfaces,
Iteratorfunktionen, zusätzliche Stringfunktionen und diverse Helferfunktionen implementiert.
Ebenfalls in diesem Modul befindet sich das Objektsystem, welches in Indico genutzt wird.
Das \emph{Data}-Modul enthält ein \emph{Data Binding}-Framework, Funktionen um serverseitige
Aktionen via JSON-RPC\footnote{Remote Procedure Call via AJAX+JSON} auszuführen und diverse
Funktionen zum Verarbeiten von diverser Datentypen wie \lstinline{Date}-Objekten und JSON.

Das größte und im weiteren Verlauf dieser Arbeit wichtigste Modul ist das \emph{UI}-Modul.
Es enthält die in Kapitel 2 erwähnte Kapselung der teilweise browserspezifischen Methoden um auf das
Dokument zuzugreifen und Komfortmethoden zur Erzeugung von DOM-Elementen. Darüberhinaus hat das
Modul verschiedene Submodule: \emph{Draw} abstrahiert das Erstellen von SVG-Grafiken bzw. im
Internet Explorer VRML-Grafiken. \emph{Extensions} und \emph{Styles} erweitern einige Objekte des
\emph{UI}-Moduls um nützliche Methoden. Das \emph{Widgets}-Submodul enthält Funktionen, um
HTML-Elemenet mit häufig benutzen Funktionen bzw. Eventhandlern zu verknüpfen oder mehrere
HTML-Elemente in einer bestimmten Art und Weise zusammenzufügen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
Das Indico-Framework stellt drei Methoden zur Verfügung, um einzelne DOM-Elemente zu selektieren.
Die Funktion \lstinline{\$E(id)} sucht ein Element anhand der eindeutigen ID und gibt dieses in
einen Wrapper verpackt zurück. \lstinline{\$N(name)} gibt eine Liste aller Elemente zurück, die den
passenden Namen haben. Neben diesen beiden Funktionen gibt es mit
\lstinline{getElementsByClassName(class)} eine weitere Funktion, die alle Elemente mit der
angegebenen CSS-Klasse zurückgibt. Eine Funktion, um Elemente anhand eines CSS-Selektors zu finden,
existiert nicht. Das Wrapper-Objekt \lstinline{XElement}, in welches alle drei Funktionen die
gefundenen DOM-Elemente verpackt, enthält neben der Referenz auf das DOM-Element diverse
Hilfsmethoden um die Arbeit mit dem Element zu erleichtern.

\item[DOM-Manipulation] \hfill \\
Indico besitzt ein globales Objekt \lstinline{Html}, welches Methoden für die meisten HTML-Elemente
besitzt. Diese akzeptieren beliebig viele Argumente, wobei das erste Argument jeweils ein Objekt
ist, welches die Attribute enthält, die das Element nach dem Erstellen besitzen soll. Beim
\lstinline{style}-Attribut ist statt der bei anderen Attributen benötigten Strings oder Zahlen auch
ein Objekt zulässig, welches die gewünschten CSS-Eigenschaften enthält. \\
Die übrigen Argumente werden zu den Child-Elementen des neuen Elements; es kann sich dabei sowohl um
DOM-Elemente als auch um \lstinline{XElement}-Objekte handeln.
\lstinline{XElement}-Objekte handeln.

Zum Verändern der Eigenschaften von Elementen muss über das \lstinline{dom}-Attribut des Wrappers
direkt auf das DOM-Element zugegriffen werden; die Manipulation des DOM-Trees selbst ist durch
Methoden wie \lstinline{detach()}, \lstinline{append()}, \lstinline{insert()}, \lstinline{remove()}
und \lstinline{replaceWith()} direkt über den Wrapper möglich. Er enthält ebenfalls eine
Hilfsmethode \lstinline{ancestorOf()} um zu überprüfen, ob ein Element ein anderes Element enthält,
wobei es sich nicht um ein direktes Unterelement handeln muss.

\item[DOM Traversal] \hfill \\
\lstinline{XElement}-Objekte besitzen einige wenige Methoden, um durch den DOM-Tree zu navigieren.
Mit \lstinline{each()} wird eine Callbackfunktion für jedes Child-Element aufgerufen,
\lstinline{getParent()} gibt das Parent-Element im Wrapper zurück. Methoden für den Zugriff auf
Geschwisterelemente fehlen ebenso wie Methoden um ausgehend von einem Element ein anderes Element zu
suchen.

\item[Events] \hfill \\
\lstinline{XElement} stellt einige Funktionen zum Registrieren von Eventhandlern zur Verfügung. Für
einige häufig genutze Events wie \emph{click}, \emph{change} und \emph{keypress} gibt es spezielle
Funktionen; für alle anderen Events gibt es die Funktion \lstinline{observeEvent()}, welche ein
Callback für ein beliebiges Event registrieren kann. Statt die DOM-Funktion
\lstinline{addEventListener()} zu nutzen wird hierbei jedoch die \lstinline{onEVENTNAME}-Eigenschaft
des DOM-Elements benutzt, was den Nachteil hat, dass der Aufruf mehrerer Handler vom Framework
gehandhabt werden muss, da die Eigenschaft jeweils immer nur auf eine Funktion zeigen kann. Das
Framework stellt sicher, dass das erste Argument der Funktion jeweils das Event-Objekt ist, jedoch
zeigt \lstinline{this} nicht auf das Element. Dadurch, dass das Event-Objekt unverändert
weitergegeben wird, sind auch zusätzliche Hilfsfunktionen notwendig, um browserunabhängig auf das
Zielelement des Events oder die gedrückte Taste im Falle eines \emph{KeyPress}-, \emph{KeyDown}-
oder \emph{KeyUp}-Events zuzugreifen.

\item[Objektsystem] \hfill \\
Das Objektsystem des Indico-Frameworks simuliert Klassen und Mixins, wobei es sich bei letzteren
ebenfalls um theoretisch eigenständig verwendbare Klassen handelt. Objekte werden mit der Funktion
\lstinline{type(name, mixins, members, ctor)} erstellt, wobei \lstinline{name} der Name der Klasse
und \lstinline{mixins} eine Liste der Mixin-Klassen ist. \lstinline{members} ist ein Objekt, welches
alle Funktionen enthält, die Memberfunktionen der Klasse werden sollen. \lstinline{ctor} ist die
Konstruktorfunktion. Bei der Verwendung von Mixins werden die Konstruktoren dieser Klassen nicht
ausgeführt; sie müssen mit \lstinline{this.NameDesMixins(...)} falls benötigt manuell ausgeführt
werden. Der Aufruf von Methoden eines Mixins, die durch eine Memberfunktionen überschrieben wurden,
ist nur über den Prototypen des Mixins möglich: \\
\lstinline{this.<mixin>.prototype.<func>.call(this, ...)}

\item[Hilfsfunktionen] \hfill \\
Mit Funktionen wie \lstinline{each}, \lstinline{map} und \lstinline{filter} bietet das
Indico-Framework einige Standardfunktionen zur funktionalen Programmierung. Darüberhinaus enthält es
viele Klassen bzw. Mixins, um \emph{Observer}, \emph{Getter} und \emph{Setter} zu ermöglichen, wobei
letztere jeweils durch einen \emph{Observer} überwacht werden können. Es werden außerdem diverse
Stringfunktionen zur Verfügung gestellt, wobei einige davon als globale Funktionen implementiert
sind und andere dem \lstinline{String}-Prototypen hinzugefügt wurden - ein Zeichen dafür, dass
mehrere Entwickler am Framework gearbeitet haben ohne sich an einheitliche Standards zu halten.

\item[UI-Elemente] \hfill \\
Indico enthält einige UI-Widgets, die teilweise im Framework enthalten sind oder darauf basieren und
außerhalb des Frameworks erweitert werden. Da diese Erweiterungen größtenteils allgemein gehalten
sind, kann man sie zum Framework dazuzählen. Das Dialog-Widget ermöglicht Inline-Popups mit Titel,
Inhalt und Buttons; zur Verwendung erstellt man eine Klasse, die von der Dialog-Klasse abgeleitet
ist und eine \lstinline{draw()}-Methode implementiert, welche sowohl den Inhalt als auch die Buttons
generiert. Letztere werden ebenfalls durch ein Widget erstellt, welches jedoch nur den Button
erstellt und einen \emph{click}-Handler hinzufügt - die Positionierung innerhalb des Dialogs findet
jeweils innerhalb der \emph{draw}-Methode statt, wodurch viel \emph{duplicate code} entsteht.
Neben dem Button-Widget werden auch die meisten anderen Formularelement von HTML durch Widgets
repräsentiert. Ebenfalls enthalten sind Funktionen zur Erzeugung und Validierung von
HTML-Formularen. Diese sind allerdings nicht komplett fehlerfrei; beispielsweise wird bei einer
Gruppe von Radiobuttons im Fehlerfall nur der erste Button als fehlerhaft markiert. Darüberhinaus
enthält das Indico-Framework ein Kalenderwidget, welches jedoch nur ein Wrapper für einen
\emph{Third-Party}-JavaScript-Kalender ist.
\imga{indico-calendar.png}{Das Kalenderwidget von Indico}{Indico-Kalenderwidget}


\item[Kompatibilität] \hfill \\
Da es sich um das aktuelle Framework von Indico handelt gibt es logischerweise keine
Kompatibilitätsprobleme mit Indico. Allerdings ist das Risiko von Konflikten mit anderen Frameworks
relativ groß, da es sehr viele globale Funktionen besitzt und teilweise kein \lstinline{var}
verwendet wird, wodurch Variablen, die eigentlich lokal sein sollten, global werden. Auf der anderen
Seite nutzt Indico keine einbuchstabigen Funktionsnamen, wodurch das Konfliktrisiko mit einigen
Frameworks wieder verringert wird - Details dazu finden sich in den folgenden Abschnitten bei den
jeweiligen Frameworks.

\item[Sonstige Features] \hfill \\
Das Indico-Framework enthält \emph{Data Binding}-Funktionen die es ermöglichen, beispielsweise den
Inhalt eines Formularfeldes mit dem eines Objekts, welches \emph{Getter} und \emph{Setter}
implementiert automatisch zu synchronisieren. Während AJAX und die Unterstützung verschiedener
Datentypen wie JSON und XML ein Standardfeature von JavaScript-Frameworks ist, unterstützt das
Indico-Framework ausschließlich JSON-RPC. Da das Framework auf Indico zugeschnitten ist und dort nur
JSON-RPC benutzt wird, ist dies jedoch kein Problem. Ein weiteres Feature ist die Erzeugung von
SVG-Grafiken, jedoch wird dieses nicht mehr benutzt.

\item[Dokumentation] \hfill \\
Das JavaScript-Framework von Indico besitzt keine externe Dokumentation. Einige Funktionen sind
jedoch im JavaDoc-Stil kommentiert, wobei die Funktionsbeschreibungen dort nicht sehr ausführlich
sind. Viele Funktionen - insbesondere nachträglich hinzugefügte - sind jedoch nicht kommentiert,
obwohl man ihren Zweck nicht auf den ersten Blick erkennt. Abgesehen vom Indico-Code, der die
meisten im Framework vorhandenen Funktionen nutzt, existieret kein Beispielcode.

\item[Lizenz] \hfill \\
Da das Framework speziell für Indico entwickelt wurde und auch nicht \emph{standalone} verfügbar
ist, steht es genau wie Indico selbst unter der GPL.
\end{description}
