\chapter{JavaScript-Frameworks}

\section{Vergleichskriterien}
Um die Frameworks miteinander vergleichen zu können, müssen einige Kriterien festgelegt werden,
anhand derer sich alle Frameworks messen lassen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
JavaScript-Frameworks kapseln den Zugriff auf Elemente in der Regel über Funktionen, die ein oder
mehrere Elemente anhand eines CSS-Selektors suchen und zurückgeben. Dabei können neben den nativ
implementierten CSS-Selektoren auch weitere Selektoren unterstützt werden.

\item[DOM-Manipulation] \hfill \\
Häufig möchte man mit JavaScript neue HTML-Elemente erstellen oder vorhandene Elemente verändern.
Dabei kann das Framework den Entwickler unterstützen, indem es beispielsweise das Verknüpfen von
Elementen und die Veränderung von CSS-Attributen vereinfacht.

\item[DOM Traversal] \hfill \\
Unter \emph{DOM Traversal} versteht man das Navigieren durch den DOM-Tree ausgehend von einem
bestimmten Element. Dabei gibt es sowohl einige Standardfunktionen die man in jedem Framework
erwarten kann als auch Komfortfunktionen.

\item[Events] \hfill \\
Wie bereits in \autoref{js-events} gezeigt unterscheiden sich die Eventsysteme der Browser
teilweise. Daher ist dies ein Bereich wo ein Framework sowohl die Browserunterschiede verbergen als
auch den Komfort erhöhen sollte.

\item[Objektsystem] \hfill \\
Manche JavaScript-Frameworks bringen ein eigenes Objektsystem mit, sodass die Arbeit mit Prototypen
und Konstruktoren vereinfacht wird und beispielsweise Mixin-Objekte unterstützt werden oder der
Aufruf einer überschriebenen Method der Parent-Klasse komfortabel möglich ist.

\item[Hilfsfunktionen] \hfill \\
Die meisten JavaScript-Frameworks bieten neben der bereits genannten Funktionalität weitere
Funktionen, die oftmals einen funktionalen Programmierstil vereinfachen oder komfortabler machen.
Allerdings sind nicht nur die funktionalen Funktionen sondern auch jegliche anderen Hilfsfunktionen
betrachtenswert.

\item[UI-Elemente] \hfill \\
Einige JavaScript-Frameworks enthalten UI-Elemente, um beispielsweise Dialoge oder Buttons zu
erzeugen. Die Frameworks unterscheiden sich dort sowohl im Umfang als auch in der Anpassbarkeit.

\item[Kompatibilität] \hfill \\
Bei der Integration in Indico ist es von Vorteil, wenn das Framework möglichst wenig Potenzial
besitzt, Konflikte zu verursachen. Dies kann durch verschiedene Ansätze erreicht werden.

\item[Sonstige Features] \hfill \\
Viele JavaScript-Frameworks haben neben den üblichen Features zusätzliche Funktionen, die in anderen
Frameworks nicht vorhanden sind.

\item[Performance] \hfill \\
Die unterschiedlichen Frameworks sind bei verschiedenen Operationen wie beispielsweise dem Zugriff
auf Elemente anhand eines CSS-Selektors unterschiedlich schnell. Allerdings spielt die Performance
im Rahmen dieser Arbeit nur eine untergeordnete Rolle, da Indico nirgends extrem viele Aktionen auf
einmal ausführt und Performanceunterschiede somit - auch dank den immer schnelleren
JavaScript-Engines - für den Endbenutzer nicht spürbar sind.

\item[Dokumentation] \hfill \\
Da mehrere Entwickler mit dem Framework arbeiten müssen und starke Fluktuation herrscht, da oftmals
Studenten für 3 bis 12 Monate an Indico arbeiten, ist eine gute Dokumentation wichtig, da es nicht
produktiv ist, wenn man erst den Quellcode des Frameworks lesen und verstehen muss um es benutzen zu
können. Insbesondere ist eine Dokumentation hilfreich, wenn sie für alle Funktionen des Frameworks
Beispielcode enthält.

\item[Lizenz] \hfill \\
Die meisten Frameworks sind unter einer OpenSource-Lizenz verfügbar.
Da Indico unter der
GNU~GPL\footnote{\href{http://www.gnu.org/licenses/gpl-2.0.txt}{http://www.gnu.org/licenses/gpl-2.0.txt}}
steht ist auf Kompatibilität mit dieser Lizenz zu achten. \autoref{img.floss-license-slide.png}
bietet einen kurzen Überblick über die verbreitetsten Open Source-Lizenzen und zeigt die
Kompatibilität: \enquote{To see if software can be combined, just start at their respective
licenses, and find a common box you can reach following the arrows.} \citep{osslic} \\
Da Indico unter der GPLv2+, d.h. \enquote{either version 2 of the License, or (at your option) any
later version}, lizenziert ist, sind alle Open Source-Lizenzen außer der \emph{Affero
GPL}\footnote{GPL mit der Erweiterung, dass auch bei einem Netzwerkzugriff auf das laufende Programm
eine \enquote{Verbreitung} stattfindet und der Quellcode zugänglich gemacht werden muss.}
kompatibel.
\img{floss-license-slide.png}{400px}{Kompatibilitätsdiagramm der verschiedenen Open
Source-Lizenzen \citep{osslic}}{OpenSource-Lizenz-Kompatibilität}
\end{description}



\section{Indico}
Das derzeit in Indico verwendet Framework besteht aus einem Loader-Script und ca. 50
JavaScript-Dateien, die das eigentliche Framework enthalten. In den HTML-Seiten von Indico wird das
Loader-Script jedoch nur im Entwicklungsmodus eingebunden; auf dem Produktivsystem werden die
einzelnen JavaScript-Dateien in einer einzelnen Datei zusammengefasst und komprimiert.

Das Framework ist in mehrere Module aufgeteilt. Im \emph{Core} werden Interfaces,
Iteratorfunktionen, zusätzliche Stringfunktionen und diverse Helferfunktionen implementiert.
Ebenfalls in diesem Modul befindet sich das Objektsystem, welches in Indico genutzt wird.
Das \emph{Data}-Modul enthält ein \emph{Data Binding}-Framework, Funktionen um serverseitige
Aktionen via JSON-RPC\footnote{Remote Procedure Call via AJAX+JSON} auszuführen und diverse
Funktionen zum Verarbeiten von diverser Datentypen wie \lstinline{Date}-Objekten und JSON.

Das größte und im weiteren Verlauf dieser Arbeit wichtigste Modul ist das \emph{UI}-Modul.
Es enthält die in Kapitel 2 erwähnte Kapselung der teilweise browserspezifischen Methoden um auf das
Dokument zuzugreifen und Komfortmethoden zur Erzeugung von DOM-Elementen. Darüberhinaus hat das
Modul verschiedene Submodule: \emph{Draw} abstrahiert das Erstellen von SVG-Grafiken bzw. im
Internet Explorer VRML-Grafiken. \emph{Extensions} und \emph{Styles} erweitern einige Objekte des
\emph{UI}-Moduls um nützliche Methoden. Das \emph{Widgets}-Submodul enthält Funktionen, um
HTML-Elemenet mit häufig benutzen Funktionen bzw. Eventhandlern zu verknüpfen oder mehrere
HTML-Elemente in einer bestimmten Art und Weise zusammenzufügen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
Das Indico-Framework stellt drei Methoden zur Verfügung, um einzelne DOM-Elemente zu selektieren.
Die Funktion \lstinline{$E(id)} sucht ein Element anhand der eindeutigen ID und gibt dieses in
einen Wrapper verpackt zurück; alternativ kann auch ein DOM-Elemente an die Funktion übergeben
werden. \lstinline{$N(name)} gibt eine Liste aller Elemente zurück, die den
passenden Namen haben. Neben diesen beiden Funktionen gibt es mit
\lstinline{getElementsByClassName(class)} eine weitere Funktion, die alle Elemente mit der
angegebenen CSS-Klasse zurückgibt. Eine Funktion, um Elemente anhand eines CSS-Selektors zu finden,
existiert nicht. Das Wrapper-Objekt \lstinline{XElement}, in welches alle drei Funktionen die
gefundenen DOM-Elemente verpackt, enthält neben der Referenz auf das DOM-Element diverse
Hilfsmethoden um die Arbeit mit dem Element zu erleichtern.

\item[DOM-Manipulation] \hfill \\
Indico besitzt ein globales Objekt \lstinline{Html}, welches Methoden für die meisten HTML-Elemente
besitzt. Diese akzeptieren beliebig viele Argumente, wobei das erste Argument jeweils ein Objekt
ist, welches die Attribute enthält, die das Element nach dem Erstellen besitzen soll. Beim
\lstinline{style}-Attribut ist statt der bei anderen Attributen benötigten Strings oder Zahlen auch
ein Objekt zulässig, welches die gewünschten CSS-Eigenschaften enthält. \\
Die übrigen Argumente werden zu den Child-Elementen des neuen Elements; es kann sich dabei sowohl um
DOM-Elemente als auch um \lstinline{XElement}-Objekte handeln.
\lstinline{XElement}-Objekte handeln.

Zum Verändern der Eigenschaften von Elementen muss über das \lstinline{dom}-Attribut des Wrappers
direkt auf das DOM-Element zugegriffen werden; die Manipulation des DOM-Trees selbst ist durch
Methoden wie \lstinline{detach()}, \lstinline{append()}, \lstinline{insert()}, \lstinline{remove()}
und \lstinline{replaceWith()} direkt über den Wrapper möglich. Er enthält ebenfalls eine
Hilfsmethode \lstinline{ancestorOf()} um zu überprüfen, ob ein Element ein anderes Element enthält,
wobei es sich nicht um ein direktes Unterelement handeln muss.

\item[DOM Traversal] \hfill \\
\lstinline{XElement}-Objekte besitzen einige wenige Methoden, um durch den DOM-Tree zu navigieren.
Mit \lstinline{each()} wird eine Callbackfunktion für jedes Child-Element aufgerufen,
\lstinline{getParent()} gibt das Parent-Element im Wrapper zurück. Methoden für den Zugriff auf
Geschwisterelemente fehlen ebenso wie Methoden um ausgehend von einem Element ein anderes Element zu
suchen.

\item[Events] \hfill \\
\lstinline{XElement} stellt einige Funktionen zum Registrieren von Eventhandlern zur Verfügung. Für
einige häufig genutze Events wie \emph{click}, \emph{change} und \emph{keypress} gibt es spezielle
Funktionen; für alle anderen Events gibt es die Funktion \lstinline{observeEvent()}, welche ein
Callback für ein beliebiges Event registrieren kann. Statt die DOM-Funktion
\lstinline{addEventListener()} zu nutzen wird hierbei jedoch die \lstinline{onEVENTNAME}-Eigenschaft
des DOM-Elements benutzt, was den Nachteil hat, dass der Aufruf mehrerer Handler vom Framework
gehandhabt werden muss, da die Eigenschaft jeweils immer nur auf eine Funktion zeigen kann. Das
Framework stellt sicher, dass das erste Argument der Funktion jeweils das Event-Objekt ist, jedoch
zeigt \lstinline{this} nicht auf das Element. Dadurch, dass das Event-Objekt unverändert
weitergegeben wird, sind auch zusätzliche Hilfsfunktionen notwendig, um browserunabhängig auf das
Zielelement des Events oder die gedrückte Taste im Falle eines \emph{KeyPress}-, \emph{KeyDown}-
oder \emph{KeyUp}-Events zuzugreifen.

\item[Objektsystem] \hfill \\
Das Objektsystem des Indico-Frameworks simuliert Klassen und Mixins, wobei es sich bei letzteren
ebenfalls um theoretisch eigenständig verwendbare Klassen handelt. Objekte werden mit der Funktion
\lstinline{type(name, mixins, members, ctor)} erstellt, wobei \lstinline{name} der Name der Klasse
und \lstinline{mixins} eine Liste der Mixin-Klassen ist. \lstinline{members} ist ein Objekt, welches
alle Funktionen enthält, die Memberfunktionen der Klasse werden sollen. \lstinline{ctor} ist die
Konstruktorfunktion. Bei der Verwendung von Mixins werden die Konstruktoren dieser Klassen nicht
ausgeführt; sie müssen mit \lstinline{this.NameDesMixins(...)} falls benötigt manuell ausgeführt
werden. Der Aufruf von Methoden eines Mixins, die durch eine Memberfunktionen überschrieben wurden,
ist nur über den Prototypen des Mixins möglich: \\
\lstinline{this.<mixin>.prototype.<func>.call(this, ...)}

\item[Hilfsfunktionen] \hfill \\
Mit Funktionen wie \lstinline{each}, \lstinline{map} und \lstinline{filter} bietet das
Indico-Framework einige Standardfunktionen zur funktionalen Programmierung. Darüberhinaus enthält es
viele Klassen bzw. Mixins, um \emph{Observer}, \emph{Getter} und \emph{Setter} zu ermöglichen, wobei
letztere jeweils durch einen \emph{Observer} überwacht werden können. Es werden außerdem diverse
Stringfunktionen zur Verfügung gestellt, wobei einige davon als globale Funktionen implementiert
sind und andere dem \lstinline{String}-Prototypen hinzugefügt wurden - ein Zeichen dafür, dass
mehrere Entwickler am Framework gearbeitet haben ohne sich an einheitliche Standards zu halten.

\item[UI-Elemente] \hfill \\
Indico enthält einige UI-Widgets, die teilweise im Framework enthalten sind oder darauf basieren und
außerhalb des Frameworks erweitert werden. Da diese Erweiterungen größtenteils allgemein gehalten
sind, kann man sie zum Framework dazuzählen. Das Dialog-Widget ermöglicht Inline-Popups mit Titel,
Inhalt und Buttons; zur Verwendung erstellt man eine Klasse, die von der Dialog-Klasse abgeleitet
ist und eine \lstinline{draw()}-Methode implementiert, welche sowohl den Inhalt als auch die Buttons
generiert. Letztere werden ebenfalls durch ein Widget erstellt, welches jedoch nur den Button
erstellt und einen \emph{click}-Handler hinzufügt - die Positionierung innerhalb des Dialogs findet
jeweils innerhalb der \emph{draw}-Methode statt, wodurch viel \emph{duplicate code} entsteht.
Neben dem Button-Widget werden auch die meisten anderen Formularelement von HTML durch Widgets
repräsentiert. Ebenfalls enthalten sind Funktionen zur Erzeugung und Validierung von
HTML-Formularen. Diese sind allerdings nicht komplett fehlerfrei; beispielsweise wird bei einer
Gruppe von Radiobuttons im Fehlerfall nur der erste Button als fehlerhaft markiert. Darüberhinaus
enthält das Indico-Framework ein Kalenderwidget, welches jedoch nur ein Wrapper für einen
\emph{Third-Party}-JavaScript-Kalender ist.
\imga{indico-calendar.png}{Das Kalenderwidget von Indico}{Indico-Kalenderwidget}

\item[Kompatibilität] \hfill \\
Da es sich um das aktuelle Framework von Indico handelt gibt es logischerweise keine
Kompatibilitätsprobleme mit Indico. Allerdings ist das Risiko von Konflikten mit anderen Frameworks
relativ groß, da es sehr viele globale Funktionen besitzt und teilweise kein \lstinline{var}
verwendet wird, wodurch Variablen, die eigentlich lokal sein sollten, global werden. Auf der anderen
Seite nutzt Indico keine einbuchstabigen Funktionsnamen, wodurch das Konfliktrisiko mit einigen
Frameworks wieder verringert wird - Details dazu finden sich in den folgenden Abschnitten bei den
jeweiligen Frameworks.

\item[Sonstige Features] \hfill \\
Das Indico-Framework enthält \emph{Data Binding}-Funktionen die es ermöglichen, beispielsweise den
Inhalt eines Formularfeldes mit dem eines Objekts, welches \emph{Getter} und \emph{Setter}
implementiert automatisch zu synchronisieren. Während AJAX und die Unterstützung verschiedener
Datentypen wie JSON und XML ein Standardfeature von JavaScript-Frameworks ist, unterstützt das
Indico-Framework ausschließlich JSON-RPC. Da das Framework auf Indico zugeschnitten ist und dort nur
JSON-RPC benutzt wird, ist dies jedoch kein Problem. Ein weiteres Feature ist die Erzeugung von
SVG-Grafiken, jedoch wird dieses nicht mehr benutzt.

\item[Dokumentation] \hfill \\
Das JavaScript-Framework von Indico besitzt keine externe Dokumentation. Einige Funktionen sind
jedoch im JavaDoc-Stil kommentiert, wobei die Funktionsbeschreibungen dort nicht sehr ausführlich
sind. Viele Funktionen - insbesondere nachträglich hinzugefügte - sind jedoch nicht kommentiert,
obwohl man ihren Zweck nicht auf den ersten Blick erkennt. Abgesehen vom Indico-Code, der die
meisten im Framework vorhandenen Funktionen nutzt, existieret kein Beispielcode.

\item[Lizenz] \hfill \\
Da das Framework speziell für Indico entwickelt wurde und auch nicht \emph{standalone} verfügbar
ist, steht es genau wie Indico selbst unter der GPL.
\end{description}





\section{Prototype}
Bei Prototype handelt es sich um eine kompakte JavaScript-Klassenbibliothek - das Release
besteht nur aus einer ca. 35 KB großen JavaScript-Datei. Es wurde ursprünglich für das \emph{Ruby on
Rails}-Framework\footnote{\href{http://rubyonrails.org/}{http://rubyonrails.org/}} entwickelt, ist
aber auch als \emph{standalone}-Bibliothek weit verbreitet.

Prototype zielt darauf ab, Webentwicklung zu vereinfachen und insbesondere die Benutzung von AJAX
sehr einfach zu machen. Durch das ausgereifte und komfortable Objektmodell fördert es die im
Web-Bereich eher wenig genutzte objektorientierte Programmierung.

In Indico wird Prototype zusammen mit \emph{Scriptaculous} bereits an einigen Stellen benutzt, um
Drag\&Drop zu ermöglichen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
Prototype bietet mehrere Methoden, um auf DOM-Elemente zuzugreifen. Die Funktion
\lstinline{$(id...)} gibt das DOM-Element mit der angegebenen ID zurück. Falls mehrere IDs angegeben
wurden, gibt die Funktion ein Array zurück. Statt einer ID kann auch ein DOM-Element übergeben
werden, womit die Funktion sehr flexibel ist. Bei allen gefundenen Elementen wird sichergestellt,
dass diese mit den Prototype-spezifischen Erweiterungen versehen wurden: Prototype nutzt keinen
Wrapper sondern modifiziert den Prototyp des \lstinline{HTMLElement}-Objekts des Browsers. Da der
Internet Explorer diese Modifikation jedoch nicht zulässt fügt die \lstinline{$}-Funktion diese
Erweiterungen falls notwendig dem jeweiligen Objekt hinzu. Das Fehlen eines Wrappers hat den
Nachteil, dass Funktionsnamen nicht mit denen nativer Funktionen kollidieren sollten und prinzipiell
zwischen einem einzelnen Element und mehreren Elementen unterschieden werden muss, da bei letzterem
ein Array notwendig ist während bei ersterem ein Array dem Entwicklerkomfort abträglich wäre; er
müsste dann jeweils \lstinline{elem[0]} nutzen, um auf das Element zuzugreifen. Diese Unterscheidung
schadet oftmals der Lesbarkeit des Codes, da keine Prototype-Methode direkt auf alle Elemente einer
Liste angewendet werden kann - man muss sie entweder selbst durchlaufen oder die
\lstinline{invoke()}-Methode des Arrays nutzen, um die Funktion auf jedes Element anzuwenden. Da
der Funktionsname jedoch als String an diese Methode übergeben werden muss, macht dies den Code
unübersichtlicher un schlechter durchsuchbar, da man nun nicht mehr einfach nach \lstinline{func(}
suchen kann, wenn man die Aufrufe von \emph{func} finden möchte.

Sofern eine Suche anhand der ID nicht ausreichend ist, kann man auch die Funktion
\lstinline{$$(selector...)} nutzen. Diese sucht Elemente andhand eines CSS-Selektors und gibt
grundsätzlichen ein Array zurück, da abgesehen von ID-Selektoren der Form \lstinline{#id} beliebig
viele Elemente gefunden werden können. Zum selektorbasierten Suchen benutzt Prototype die
\emph{Sizzle}-Middleware\footnote{\href{http://sizzlejs.com}{http://sizzlejs.com}}.

\item[DOM-Manipulation] \hfill \\
Das \lstinline{Element}-Objekt enthält nicht nur alle Methoden, die den
\lstinline{HTMLElement}-Objekten hinzugefügt werden, sondern dient auch der Erstellung neuer
Elemente. Um mit Prototype ein neues HTML-Element zu erstellen, nutzt man den
\lstinline{Element(tagName[, attributes])}-Konstruktor, wobei man den Namen des Elements als String
und die optionalen Attribute als Objekt übergibt. Da letztere unverändert als Attribute des neuen
elements übernommen werden, dürfen die Werte ausschließlich Strings und Zahlen sein. Wenn das neue
Element nicht leer sein soll, kann man die \lstinline{update()}-Methode nutzen, um ihm einen Inhalt
zuzuweisen - dieser kann entweder ein HTML-String, ein HTML-Element oder ein Objekt sein, welches
entweder eine \lstinline{toHTML()}- oder \lstinline{toElement()}-Methode besitzt.

Da Prototype keinen Wrapper nutzt, kann auf Element-Eigenschaften direkt zugegriffen werden; wenn
explizit der Zugriff auf ein Attribut gewünscht ist, kann man die Methoden
\lstinline{readAttribute()} bzw. \lstinline{writeAttribute()} nutzen. Für den Zugriff auf diverse
Eigenschaften wie der CSS-Klasse (hinzufügen, entfernen, \emph{contains}), der Sichtbarkeit und bei
Formularelementen dem Wert und dem \emph{Disabled}-Flag  stellt Prototype ebenfalls Methoden zur
Verfügung. Darüberhinaus können auch CSS-Eigenschaften über ein Objekt gesetzt werden, sodass
mehrere Eigenschaften auf einmal geändert werden können. Ein insbesondere für grafiklastige oder
pixelgenau arbeitende Webapplikationen nützliches Feature ist die \lstinline{measure()}-Methode.
Diese gibt ein Objekt zurück, welches Zugriff auf alle Größen- und Positionsinformationen bietet.

Auch für die Nanipulation des DOM-Trees bietet Prototype diverse Funktionen. Neben den
Standardfunktionen bietet Prototype dort auch Komfortfunktionen wie \lstinline{wrap()}, womit ein
Element durch ein neues Element umschlossen wird und das neue Element zurückgegeben wird.

\item[DOM Traversal] \hfill \\
Um ausgehend von einem Element ein anderes, unterhalb liegendes, Element zu finden, bietet Prototype
mit der \lstinline{select(selector...)}-Methode einen komfortablen Weg, das Element anhand eines
CSS-Selektors zu finden. Zur einfachen Navigation innerhalb der DOM-Struktur stellt Prototype
ebenfalls Methoden zur Verfügung, wobei teilweise mehrere Methoden für fast denselben Zweck
existieren. Sowohl \lstinline{adjacent()} als auch \lstinline{siblings()} geben die
Geschwisterelemente eines Elements zurück - der einzige Unterschied ist, dass \lstinline{adjacent()}
ein Filtern der Elemente durch einen CSS-Selektor erlaubt.

\item[Events] \hfill \\
Prototype bietet zwei Möglichkeiten, Events zu registrieren. Die klassische Möglichkeit ist über die
\lstinline{observe(eventName, handler)}-Methode, wobei \lstinline{handler} für alle Events
ausgeführt werden, die das Element erreichen - also Events die vom Element selbst oder einem
enthaltenen Elemente ausgehen. Da die Methode das Element selbst zurückgibt, besteht die einzige
Möglichkeit, den Event-Handler wieder zu entfernen, darin, ihn anhand des Eventnamens und der
Handler-Funktion zu identifizieren. Dazu dient die Methode
\lstinline{stopObserving([eventName][, handler])}, wobei beide Argumente optional sind; wenn
ein Argument nicht angegeben ist, werden alle entsprechenden Event-Handler entfernt.

Der neue und auch komfortablere Weg ist über die Methode
\lstinline{on(eventName[, selector], handler)}. Sofern ein CSS-Selektor angegeben wurde,
wird aus dem Event-Handler ein \emph{Delegate}, d.h. er reagiert nur noch auf Events, die von einem
enthaltenen Element ausgelöst wurden, welches dem CSS-Selektor entspricht. Ein weiterer Vorteil
dieser Methode ist ihr Rückgabewert. Sie gibt ein Objekt zurück, welches zwei Methodem
\lstinline{start()} und \lstinline{stop()} enthält, wobei letztere den Event-Handler entfernt und
erstere ihn wieder hinzufügt.

In beiden Fällen stellt Prototype sicher, dass \lstinline{this} auf das ursprüngliche Element zeigt,
wobei sich bei einem \emph{Delegate} darüber streiten lässt, ob \lstinline{this} nicht eher auf das
Element zeigen sollte, von dem das Event ausgeht. Als Parameter erhält die Callbackmethode jeweils
das durch Prototype erweiterte Event-Objekt: Das Zielelement ist browserunabhängig über die
\lstinline{target}-Eigenschaft verfügbar und die \lstinline{stop()}-Methode verhindert sowohl das
Aufsteigen des Events im DOM-Tree als auch das Ausführen der Standardaktion (beispielsweise das
Laden einer neuen Seite bei einem Link). Eine browserunabhängige Möglichkeit, nur eine dieser
Aktionen zu verhindern, fehlt jedoch. Sofern \lstinline{on()} zum Registrieren des Eventhandlers
genutzt wurde, wird das Zielelement in einem zusätzlichen Parameter an da Callback übergeben.


\item[Objektsystem] \hfill \\
Das Objektsystem von Prototype bietet Klassen, Vererbung und Mixins, wobei eine Klasse beliebig
viele Mixins aber nur eine Parentklasse besitzen kann. Eine neue Klasse erstellt man, indem man den
Rückgabewert der Funktion \lstinline{Class.create([superclass][, methods...])} einer Variable
zuweist - es handelt sich dabei um die Konstruktorfunktion der neuen Klasse. Sofern man von einer
anderen Klasse erben möchte, übergibt man diese Klasse als erstes Argument. Alle weiteren Argumente
sind JavaScript-Objekte, die Funktionen enthalten. Diese werden der neuen Klasse hinzugefügt, wobei
bereits vorhandene Methoden überschrieben werden - wenn man Mixins benutzt, sollte man diese also
vor dem Objekt übergeben, welches die neuen Funktionen der Klassen enthält. Beim Überschreiben von
Methoden der Parentklasse nutzt Prototype den dynamischen Character von JavaScript voll aus: Sofern
das erste Argument der neuen Methode den Namen \lstinline{$super} hat, zeigt dieses auf die
überschriebene Methode, sodass sie einfach und ohne zusätzlichen Code aufgerufen werden kann.


\item[Hilfsfunktionen] \hfill \\
Prototype stellt keine globalen Hilfsfunktionen zur Verfügung, allerdings erweitert es die
Prototypen und Konstruktoren bestehender Objekte, sodass über diese Objekte auf die die zahlreichen
Hilfsfunktionen von Prototype zugegriffen werden kann.

\item[UI-Elemente] \hfill \\
Prototype enthält keine UI-Widgets, allerdings wird es oftmals zusammen mit
Scriptaculous\footnote{\href{http://script.aculo.us}{http://script.aculo.us}} verwendet wird. Diese
Erweiterung erlaubt Drag\&Drop von Elementen, sortierbare Listen, Autovervollständigung von
Textfeldern, Inline-Editierung von Texten/Werten und ein \emph{Slider}-Widget zur Auswahl eines
numerischen Werts.

\item[Kompatibilität] \hfill \\
Prototype wird bereits in einigen Teilen von Indico genutzt, daher ist es an sich mit dem übrigen
Code von Indico kompatibel, obwohl sowohl Indico als auch Prototype einige
\lstinline{$X}-Funktionen nutzen, wobei \lstinline{$A} sogar in beiden Frameworks definiert wird -
allerdings überschreibt die \lstinline{$A}-Funktion von Indico die aus Prototype, wobei es keine
Konflikte gibt, da beide Funktionen denselben Zweck haben und auch von den Parametern her
identisch sind. Neben diesem Konflikt gibt keien weiteren Probleme, obwohl Prototype sehr invasiv
ist: Wie auch das Indico-Framework definiert es mehrere globale Objekte mit \enquote{Standardnamen}
wie \emph{Event} oder \emph{Element}. Darüberhinaus erweitert es die Prototypen sowohl von nativen
Objekten wie \lstinline{Array}, \lstinline{Number} und \lstinline{String} - jedoch nicht den
\lstinline{Object}-Prototypen, da Veränderungen an diesem mit hoher Wahrscheinlichkeit Probleme
verursachen; beispielsweise verändert sich das Verhalten von \lstinline{for(var elem in object)}
dadurch - als auch von Hostobjekten wie \lstinline{HTMLElement}. Gerade letzteres ist aufgrund des
größtenteils undefinierten Verhaltens dieser Objekte riskant.

\item[Sonstige Features] \hfill \\
Die meisten Methoden von Prototype kann man sowohl als Methode als auch als Funktion aufrufen, wobei
bei letzterem das Objekt als Funktionsargument übergeben wird. Prototype enthält selbst keine
Funktionen zur Animation von Elementen, jedoch bietet Scriptaculous entsprechende Funktionalität.

\item[Dokumentation] \hfill \\
Prototype besitzt eine ausführliche Online-Dokumentation. Zu jeder Funktion gibt es neben der
Beschreibung auch ein kurzes Codebeispiel, allerdings sind diese Beispiele statisch und können nicht
ausgeführt werden, ohne den Code manuell in eine HTML-Datei zu kopieren. Der Quellcode von Prototype
ist ausführlich kommentiert und in Module unterteilt, die jedoch im Release in eine einzelne Datei
zusammengefasst sind.

\item[Lizenz] \hfill \\
Prototype steht unter der
MIT-Lizenz\footnote{\href{http://www.opensource.org/licenses/mit-license.php}{http://www.opensource.org/licenses/mit-license.php}}.
\end{description}
