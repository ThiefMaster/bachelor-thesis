\chapter{JavaScript-Frameworks}

\section{Vergleichskriterien}
Um die Frameworks miteinander vergleichen zu können, müssen einige Kriterien festgelegt werden,
anhand derer sich alle Frameworks messen lassen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
JavaScript-Frameworks kapseln den Zugriff auf Elemente in der Regel über Funktionen, die ein oder
mehrere Elemente anhand eines CSS-Selektors suchen und zurückgeben. Dabei können neben den nativ
implementierten CSS-Selektoren auch weitere Selektoren unterstützt werden.

\item[DOM-Manipulation] \hfill \\
Häufig möchte man mit JavaScript neue HTML-Elemente erstellen oder vorhandene Elemente verändern.
Dabei kann das Framework den Entwickler unterstützen, indem es beispielsweise das Verknüpfen von
Elementen und die Veränderung von CSS-Attributen vereinfacht.

\item[DOM Traversal] \hfill \\
Unter \emph{DOM Traversal} versteht man das Navigieren durch den DOM-Tree ausgehend von einem
bestimmten Element. Dabei gibt es sowohl einige Standardfunktionen die man in jedem Framework
erwarten kann als auch Komfortfunktionen.

\item[Events] \hfill \\
Wie bereits in \autoref{js-events} gezeigt unterscheiden sich die Eventsysteme der Browser
teilweise. Daher ist dies ein Bereich wo ein Framework sowohl die Browserunterschiede verbergen als
auch den Komfort erhöhen sollte.

\item[Objektsystem] \hfill \\
Manche JavaScript-Frameworks bringen ein eigenes Objektsystem mit, sodass die Arbeit mit Prototypen
und Konstruktoren vereinfacht wird und beispielsweise Mixin-Objekte unterstützt werden oder der
Aufruf einer überschriebenen Method der Parent-Klasse komfortabel möglich ist.

\item[Hilfsfunktionen] \hfill \\
Die meisten JavaScript-Frameworks bieten neben der bereits genannten Funktionalität weitere
Funktionen, die oftmals einen funktionalen Programmierstil vereinfachen oder komfortabler machen.
Allerdings sind nicht nur die funktionalen Funktionen sondern auch jegliche anderen Hilfsfunktionen
betrachtenswert.

\item[UI-Elemente] \hfill \\
Einige JavaScript-Frameworks enthalten UI-Elemente, um beispielsweise Dialoge oder Buttons zu
erzeugen. Die Frameworks unterscheiden sich dort sowohl im Umfang als auch in der Anpassbarkeit.

\item[Kompatibilität] \hfill \\
Bei der Integration in Indico ist es von Vorteil, wenn das Framework möglichst wenig Potenzial
besitzt, Konflikte zu verursachen. Dies kann durch verschiedene Ansätze erreicht werden.

\item[Sonstige Features] \hfill \\
Viele JavaScript-Frameworks haben neben den üblichen Features zusätzliche Funktionen, die in anderen
Frameworks nicht vorhanden sind.

\item[Performance] \hfill \\
Die unterschiedlichen Frameworks sind bei verschiedenen Operationen wie beispielsweise dem Zugriff
auf Elemente anhand eines CSS-Selektors unterschiedlich schnell. Allerdings spielt die Performance
im Rahmen dieser Arbeit nur eine untergeordnete Rolle, da Indico nirgends extrem viele Aktionen auf
einmal ausführt und Performanceunterschiede somit - auch dank den immer schnelleren
JavaScript-Engines - für den Endbenutzer nicht spürbar sind.

\item[Dokumentation] \hfill \\
Da mehrere Entwickler mit dem Framework arbeiten müssen und starke Fluktuation herrscht, da oftmals
Studenten für 3 bis 12 Monate an Indico arbeiten, ist eine gute Dokumentation wichtig, da es nicht
produktiv ist, wenn man erst den Quellcode des Frameworks lesen und verstehen muss um es benutzen zu
können. Insbesondere ist eine Dokumentation hilfreich, wenn sie für alle Funktionen des Frameworks
Beispielcode enthält.

\item[Lizenz] \hfill \\
Die meisten Frameworks sind unter einer OpenSource-Lizenz verfügbar.
Da Indico unter der
GNU~GPL\footnote{\href{http://www.gnu.org/licenses/gpl-2.0.txt}{http://www.gnu.org/licenses/gpl-2.0.txt}}
steht ist auf Kompatibilität mit dieser Lizenz zu achten. \autoref{img.floss-license-slide.png}
bietet einen kurzen Überblick über die verbreitetsten Open Source-Lizenzen und zeigt die
Kompatibilität: \enquote{To see if software can be combined, just start at their respective
licenses, and find a common box you can reach following the arrows.} \citep{osslic} \\
Da Indico unter der GPLv2+, d.h. \enquote{either version 2 of the License, or (at your option) any
later version}, lizenziert ist, sind alle Open Source-Lizenzen außer der \emph{Affero
GPL}\footnote{GPL mit der Erweiterung, dass auch bei einem Netzwerkzugriff auf das laufende Programm
eine \enquote{Verbreitung} stattfindet und der Quellcode zugänglich gemacht werden muss.}
kompatibel.
\img{floss-license-slide.png}{400px}{Kompatibilitätsdiagramm der verschiedenen Open
Source-Lizenzen \citep{osslic}}{OpenSource-Lizenz-Kompatibilität}
\end{description}



\section{Indico}
Das derzeit in Indico verwendet Framework besteht aus einem Loader-Script und ca. 50
JavaScript-Dateien, die das eigentliche Framework enthalten. In den HTML-Seiten von Indico wird das
Loader-Script jedoch nur im Entwicklungsmodus eingebunden; auf dem Produktivsystem werden die
einzelnen JavaScript-Dateien in einer einzelnen Datei zusammengefasst und komprimiert.

Das Framework ist in mehrere Module aufgeteilt. Im \emph{Core} werden Interfaces,
Iteratorfunktionen, zusätzliche Stringfunktionen und diverse Helferfunktionen implementiert.
Ebenfalls in diesem Modul befindet sich das Objektsystem, welches in Indico genutzt wird.
Das \emph{Data}-Modul enthält ein \emph{Data Binding}-Framework, Funktionen um serverseitige
Aktionen via JSON-RPC\footnote{Remote Procedure Call via AJAX+JSON} auszuführen und diverse
Funktionen zum Verarbeiten von diverser Datentypen wie \lstinline{Date}-Objekten und JSON.

Das größte und im weiteren Verlauf dieser Arbeit wichtigste Modul ist das \emph{UI}-Modul.
Es enthält die in Kapitel 2 erwähnte Kapselung der teilweise browserspezifischen Methoden um auf das
Dokument zuzugreifen und Komfortmethoden zur Erzeugung von DOM-Elementen. Darüberhinaus hat das
Modul verschiedene Submodule: \emph{Draw} abstrahiert das Erstellen von SVG-Grafiken bzw. im
Internet Explorer VRML-Grafiken. \emph{Extensions} und \emph{Styles} erweitern einige Objekte des
\emph{UI}-Moduls um nützliche Methoden. Das \emph{Widgets}-Submodul enthält Funktionen, um
HTML-Elemenet mit häufig benutzen Funktionen bzw. Eventhandlern zu verknüpfen oder mehrere
HTML-Elemente in einer bestimmten Art und Weise zusammenzufügen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
Das Indico-Framework stellt drei Methoden zur Verfügung, um einzelne DOM-Elemente zu selektieren.
Die Funktion \lstinline{$E(id)} sucht ein Element anhand der eindeutigen ID und gibt dieses in
einen Wrapper verpackt zurück; alternativ kann auch ein DOM-Elemente an die Funktion übergeben
werden. \lstinline{$N(name)} gibt eine Liste aller Elemente zurück, die den
passenden Namen haben. Neben diesen beiden Funktionen gibt es mit
\lstinline{getElementsByClassName(class)} eine weitere Funktion, die alle Elemente mit der
angegebenen CSS-Klasse zurückgibt. Eine Funktion, um Elemente anhand eines CSS-Selektors zu finden,
existiert nicht. Das Wrapper-Objekt \lstinline{XElement}, in welches alle drei Funktionen die
gefundenen DOM-Elemente verpackt, enthält neben der Referenz auf das DOM-Element diverse
Hilfsmethoden um die Arbeit mit dem Element zu erleichtern.

\item[DOM-Manipulation] \hfill \\
Indico besitzt ein globales Objekt \lstinline{Html}, welches Methoden für die meisten HTML-Elemente
besitzt. Diese akzeptieren beliebig viele Argumente, wobei das erste Argument jeweils ein Objekt
ist, welches die Attribute enthält, die das Element nach dem Erstellen besitzen soll. Beim
\lstinline{style}-Attribut ist statt der bei anderen Attributen benötigten Strings oder Zahlen auch
ein Objekt zulässig, welches die gewünschten CSS-Eigenschaften enthält. \\
Die übrigen Argumente werden zu den Child-Elementen des neuen Elements; es kann sich dabei sowohl um
DOM-Elemente als auch um \lstinline{XElement}-Objekte handeln.
\lstinline{XElement}-Objekte handeln.

Zum Verändern der Eigenschaften von Elementen muss über das \lstinline{dom}-Attribut des Wrappers
direkt auf das DOM-Element zugegriffen werden; die Manipulation des DOM-Trees selbst ist durch
Methoden wie \lstinline{detach()}, \lstinline{append()}, \lstinline{insert()}, \lstinline{remove()}
und \lstinline{replaceWith()} direkt über den Wrapper möglich. Er enthält ebenfalls eine
Hilfsmethode \lstinline{ancestorOf()} um zu überprüfen, ob ein Element ein anderes Element enthält,
wobei es sich nicht um ein direktes Unterelement handeln muss.

\item[DOM Traversal] \hfill \\
\lstinline{XElement}-Objekte besitzen einige wenige Methoden, um durch den DOM-Tree zu navigieren.
Mit \lstinline{each()} wird eine Callbackfunktion für jedes Child-Element aufgerufen,
\lstinline{getParent()} gibt das Parent-Element im Wrapper zurück. Methoden für den Zugriff auf
Geschwisterelemente fehlen ebenso wie Methoden um ausgehend von einem Element ein anderes Element zu
suchen.

\item[Events] \hfill \\
\lstinline{XElement} stellt einige Funktionen zum Registrieren von Eventhandlern zur Verfügung. Für
einige häufig genutze Events wie \emph{click}, \emph{change} und \emph{keypress} gibt es spezielle
Funktionen; für alle anderen Events gibt es die Funktion \lstinline{observeEvent()}, welche ein
Callback für ein beliebiges Event registrieren kann. Statt die DOM-Funktion
\lstinline{addEventListener()} zu nutzen wird hierbei jedoch die \lstinline{onEVENTNAME}-Eigenschaft
des DOM-Elements benutzt, was den Nachteil hat, dass der Aufruf mehrerer Handler vom Framework
gehandhabt werden muss, da die Eigenschaft jeweils immer nur auf eine Funktion zeigen kann. Das
Framework stellt sicher, dass das erste Argument der Funktion jeweils das Event-Objekt ist, jedoch
zeigt \lstinline{this} nicht auf das Element. Dadurch, dass das Event-Objekt unverändert
weitergegeben wird, sind auch zusätzliche Hilfsfunktionen notwendig, um browserunabhängig auf das
Zielelement des Events oder die gedrückte Taste im Falle eines \emph{KeyPress}-, \emph{KeyDown}-
oder \emph{KeyUp}-Events zuzugreifen.

\item[Objektsystem] \hfill \\
Das Objektsystem des Indico-Frameworks simuliert Klassen und Mixins, wobei es sich bei letzteren
ebenfalls um theoretisch eigenständig verwendbare Klassen handelt. Objekte werden mit der Funktion
\lstinline{type(name, mixins, members, ctor)} erstellt, wobei \lstinline{name} der Name der Klasse
und \lstinline{mixins} eine Liste der Mixin-Klassen ist. \lstinline{members} ist ein Objekt, welches
alle Funktionen enthält, die Memberfunktionen der Klasse werden sollen. \lstinline{ctor} ist die
Konstruktorfunktion. Bei der Verwendung von Mixins werden die Konstruktoren dieser Klassen nicht
ausgeführt; sie müssen mit \lstinline{this.NameDesMixins(...)} falls benötigt manuell ausgeführt
werden. Der Aufruf von Methoden eines Mixins, die durch eine Memberfunktionen überschrieben wurden,
ist nur über den Prototypen des Mixins möglich: \\
\lstinline{this.<mixin>.prototype.<func>.call(this, ...)}

\item[Hilfsfunktionen] \hfill \\
Mit Funktionen wie \lstinline{each}, \lstinline{map} und \lstinline{filter} bietet das
Indico-Framework einige Standardfunktionen zur funktionalen Programmierung. Darüberhinaus enthält es
viele Klassen bzw. Mixins, um \emph{Observer}, \emph{Getter} und \emph{Setter} zu ermöglichen, wobei
letztere jeweils durch einen \emph{Observer} überwacht werden können. Es werden außerdem diverse
Stringfunktionen zur Verfügung gestellt, wobei einige davon als globale Funktionen implementiert
sind und andere dem \lstinline{String}-Prototypen hinzugefügt wurden - ein Zeichen dafür, dass
mehrere Entwickler am Framework gearbeitet haben ohne sich an einheitliche Standards zu halten.

\item[UI-Elemente] \hfill \\
Indico enthält einige UI-Widgets, die teilweise im Framework enthalten sind oder darauf basieren und
außerhalb des Frameworks erweitert werden. Da diese Erweiterungen größtenteils allgemein gehalten
sind, kann man sie zum Framework dazuzählen. Das Dialog-Widget ermöglicht Inline-Popups mit Titel,
Inhalt und Buttons; zur Verwendung erstellt man eine Klasse, die von der Dialog-Klasse abgeleitet
ist und eine \lstinline{draw()}-Methode implementiert, welche sowohl den Inhalt als auch die Buttons
generiert. Letztere werden ebenfalls durch ein Widget erstellt, welches jedoch nur den Button
erstellt und einen \emph{click}-Handler hinzufügt - die Positionierung innerhalb des Dialogs findet
jeweils innerhalb der \emph{draw}-Methode statt, wodurch viel \emph{duplicate code} entsteht.
Neben dem Button-Widget werden auch die meisten anderen Formularelement von HTML durch Widgets
repräsentiert. Ebenfalls enthalten sind Funktionen zur Erzeugung und Validierung von
HTML-Formularen. Diese sind allerdings nicht komplett fehlerfrei; beispielsweise wird bei einer
Gruppe von Radiobuttons im Fehlerfall nur der erste Button als fehlerhaft markiert. Darüberhinaus
enthält das Indico-Framework ein Kalenderwidget, welches jedoch nur ein Wrapper für einen
\emph{Third-Party}-JavaScript-Kalender ist.
\imga{indico-calendar.png}{Das Kalenderwidget von Indico}{Indico-Kalenderwidget}

\item[Kompatibilität] \hfill \\
Da es sich um das aktuelle Framework von Indico handelt gibt es logischerweise keine
Kompatibilitätsprobleme mit Indico. Allerdings ist das Risiko von Konflikten mit anderen Frameworks
relativ groß, da es sehr viele globale Funktionen besitzt und teilweise kein \lstinline{var}
verwendet wird, wodurch Variablen, die eigentlich lokal sein sollten, global werden. Auf der anderen
Seite nutzt Indico keine einbuchstabigen Funktionsnamen, wodurch das Konfliktrisiko mit einigen
Frameworks wieder verringert wird - Details dazu finden sich in den folgenden Abschnitten bei den
jeweiligen Frameworks.

\item[Sonstige Features] \hfill \\
Das Indico-Framework enthält \emph{Data Binding}-Funktionen die es ermöglichen, beispielsweise den
Inhalt eines Formularfeldes mit dem eines Objekts, welches \emph{Getter} und \emph{Setter}
implementiert automatisch zu synchronisieren. Während AJAX und die Unterstützung verschiedener
Datentypen wie JSON und XML ein Standardfeature von JavaScript-Frameworks ist, unterstützt das
Indico-Framework ausschließlich JSON-RPC. Da das Framework auf Indico zugeschnitten ist und dort nur
JSON-RPC benutzt wird, ist dies jedoch kein Problem. Ein weiteres Feature ist die Erzeugung von
SVG-Grafiken, jedoch wird dieses nicht mehr benutzt.

\item[Dokumentation] \hfill \\
Das JavaScript-Framework von Indico besitzt keine externe Dokumentation. Einige Funktionen sind
jedoch im JavaDoc-Stil kommentiert, wobei die Funktionsbeschreibungen dort nicht sehr ausführlich
sind. Viele Funktionen - insbesondere nachträglich hinzugefügte - sind jedoch nicht kommentiert,
obwohl man ihren Zweck nicht auf den ersten Blick erkennt. Abgesehen vom Indico-Code, der die
meisten im Framework vorhandenen Funktionen nutzt, existieret kein Beispielcode.

\item[Lizenz] \hfill \\
Da das Framework speziell für Indico entwickelt wurde und auch nicht \emph{standalone} verfügbar
ist, steht es genau wie Indico selbst unter der GPL.
\end{description}





\section{Prototype}
Bei Prototype handelt es sich um eine kompakte JavaScript-Klassenbibliothek - das Release
besteht nur aus einer ca. 35 KB großen JavaScript-Datei. Es wurde ursprünglich für das \emph{Ruby on
Rails}-Framework\footnote{\href{http://rubyonrails.org/}{http://rubyonrails.org/}} entwickelt, ist
aber auch als \emph{standalone}-Bibliothek weit verbreitet. Sie kann auf
\href{http://www.prototypejs.org}{http://www.prototypejs.org} heruntergeladen werden.

Prototype zielt darauf ab, Webentwicklung zu vereinfachen und insbesondere die Benutzung von AJAX
sehr einfach zu machen. Durch das ausgereifte und komfortable Objektmodell fördert es die im
Web-Bereich eher wenig genutzte objektorientierte Programmierung.

In Indico wird Prototype zusammen mit \emph{Scriptaculous} bereits an einigen Stellen benutzt, um
Drag\&Drop zu ermöglichen.

\begin{description}
\item[DOM-Zugriff] \hfill \\
Prototype bietet mehrere Methoden, um auf DOM-Elemente zuzugreifen. Die Funktion
\lstinline{$(id...)} gibt das DOM-Element mit der angegebenen ID zurück. Falls mehrere IDs angegeben
wurden, gibt die Funktion ein Array zurück. Statt einer ID kann auch ein DOM-Element übergeben
werden, womit die Funktion sehr flexibel ist. Bei allen gefundenen Elementen wird sichergestellt,
dass diese mit den Prototype-spezifischen Erweiterungen versehen wurden: Prototype nutzt keinen
Wrapper sondern modifiziert den Prototyp des \lstinline{HTMLElement}-Objekts des Browsers. Da der
Internet Explorer diese Modifikation jedoch nicht zulässt fügt die \lstinline{$}-Funktion diese
Erweiterungen falls notwendig dem jeweiligen Objekt hinzu. Das Fehlen eines Wrappers hat den
Nachteil, dass Funktionsnamen nicht mit denen nativer Funktionen kollidieren sollten und prinzipiell
zwischen einem einzelnen Element und mehreren Elementen unterschieden werden muss, da bei letzterem
ein Array notwendig ist während bei ersterem ein Array dem Entwicklerkomfort abträglich wäre; er
müsste dann jeweils \lstinline{elem[0]} nutzen, um auf das Element zuzugreifen. Diese Unterscheidung
schadet oftmals der Lesbarkeit des Codes, da keine Prototype-Methode direkt auf alle Elemente einer
Liste angewendet werden kann - man muss sie entweder selbst durchlaufen oder die
\lstinline{invoke()}-Methode des Arrays nutzen, um die Funktion auf jedes Element anzuwenden. Da
der Funktionsname jedoch als String an diese Methode übergeben werden muss, macht dies den Code
unübersichtlicher un schlechter durchsuchbar, da man nun nicht mehr einfach nach \lstinline{func(}
suchen kann, wenn man die Aufrufe von \emph{func} finden möchte.

Sofern eine Suche anhand der ID nicht ausreichend ist, kann man auch die Funktion
\lstinline{$$(selector...)} nutzen. Diese sucht Elemente andhand eines CSS-Selektors und gibt
grundsätzlichen ein Array zurück, da abgesehen von ID-Selektoren der Form \lstinline{#id} beliebig
viele Elemente gefunden werden können. Zum selektorbasierten Suchen benutzt Prototype die
\emph{Sizzle}-Middleware\footnote{\href{http://sizzlejs.com}{http://sizzlejs.com}}.

\item[DOM-Manipulation] \hfill \\
Das \lstinline{Element}-Objekt enthält nicht nur alle Methoden, die den
\lstinline{HTMLElement}-Objekten hinzugefügt werden, sondern dient auch der Erstellung neuer
Elemente. Um mit Prototype ein neues HTML-Element zu erstellen, nutzt man den
\lstinline{Element(tagName[, attributes])}-Konstruktor, wobei man den Namen des Elements als String
und die optionalen Attribute als Objekt übergibt. Da letztere unverändert als Attribute des neuen
elements übernommen werden, dürfen die Werte ausschließlich Strings und Zahlen sein. Wenn das neue
Element nicht leer sein soll, kann man die \lstinline{update()}-Methode nutzen, um ihm einen Inhalt
zuzuweisen - dieser kann entweder ein HTML-String, ein HTML-Element oder ein Objekt sein, welches
entweder eine \lstinline{toHTML()}- oder \lstinline{toElement()}-Methode besitzt.

Da Prototype keinen Wrapper nutzt, kann auf Element-Eigenschaften direkt zugegriffen werden; wenn
explizit der Zugriff auf ein Attribut gewünscht ist, kann man die Methoden
\lstinline{readAttribute()} bzw. \lstinline{writeAttribute()} nutzen. Für den Zugriff auf diverse
Eigenschaften wie der CSS-Klasse (hinzufügen, entfernen, \emph{contains}), der Sichtbarkeit und bei
Formularelementen dem Wert und dem \emph{Disabled}-Flag  stellt Prototype ebenfalls Methoden zur
Verfügung. Darüberhinaus können auch CSS-Eigenschaften über ein Objekt gesetzt werden, sodass
mehrere Eigenschaften auf einmal geändert werden können. Ein insbesondere für grafiklastige oder
pixelgenau arbeitende Webapplikationen nützliches Feature ist die \lstinline{measure()}-Methode.
Diese gibt ein Objekt zurück, welches Zugriff auf alle Größen- und Positionsinformationen bietet.

Auch für die Manipulation des DOM-Trees bietet Prototype diverse Funktionen. Neben den
Standardfunktionen bietet Prototype dort auch Komfortfunktionen wie \lstinline{wrap()}, womit ein
Element durch ein neues Element umschlossen wird und das neue Element zurückgegeben wird.

\item[DOM Traversal] \hfill \\
Um ausgehend von einem Element ein anderes, unterhalb liegendes, Element zu finden, bietet Prototype
mit der \lstinline{select(selector...)}-Methode einen komfortablen Weg, das Element anhand eines
CSS-Selektors zu finden. Zur einfachen Navigation innerhalb der DOM-Struktur stellt Prototype
ebenfalls Methoden zur Verfügung, wobei teilweise mehrere Methoden für fast denselben Zweck
existieren. Sowohl \lstinline{adjacent()} als auch \lstinline{siblings()} geben die
Geschwisterelemente eines Elements zurück - der einzige Unterschied ist, dass \lstinline{adjacent()}
ein Filtern der Elemente durch einen CSS-Selektor erlaubt.

\item[Events] \hfill \\
Prototype bietet zwei Möglichkeiten, Events zu registrieren. Die klassische Möglichkeit ist über die
\lstinline{observe(eventName, handler)}-Methode, wobei \lstinline{handler} für alle Events
ausgeführt werden, die das Element erreichen - also Events die vom Element selbst oder einem
enthaltenen Elemente ausgehen. Da die Methode das Element selbst zurückgibt, besteht die einzige
Möglichkeit, den Event-Handler wieder zu entfernen, darin, ihn anhand des Eventnamens und der
Handler-Funktion zu identifizieren. Dazu dient die Methode
\lstinline{stopObserving([eventName][, handler])}, wobei beide Argumente optional sind; wenn
ein Argument nicht angegeben ist, werden alle entsprechenden Event-Handler entfernt.

Der neue und auch komfortablere Weg ist über die Methode
\lstinline{on(eventName[, selector], handler)}. Sofern ein CSS-Selektor angegeben wurde,
wird aus dem Event-Handler ein \emph{Delegate}, d.h. er reagiert nur noch auf Events, die von einem
enthaltenen Element ausgelöst wurden, welches dem CSS-Selektor entspricht. Ein weiterer Vorteil
dieser Methode ist ihr Rückgabewert. Sie gibt ein Objekt zurück, welches zwei Methodem
\lstinline{start()} und \lstinline{stop()} enthält, wobei letztere den Event-Handler entfernt und
erstere ihn wieder hinzufügt.

In beiden Fällen stellt Prototype sicher, dass \lstinline{this} auf das ursprüngliche Element zeigt,
wobei sich bei einem \emph{Delegate} darüber streiten lässt, ob \lstinline{this} nicht eher auf das
Element zeigen sollte, von dem das Event ausgeht. Als Parameter erhält die Callbackmethode jeweils
das durch Prototype erweiterte Event-Objekt: Das Zielelement ist browserunabhängig über die
\lstinline{target}-Eigenschaft verfügbar und die \lstinline{stop()}-Methode verhindert sowohl das
Aufsteigen des Events im DOM-Tree als auch das Ausführen der Standardaktion (beispielsweise das
Laden einer neuen Seite bei einem Link). Eine browserunabhängige Möglichkeit, nur eine dieser
Aktionen zu verhindern, fehlt jedoch. Sofern \lstinline{on()} zum Registrieren des Eventhandlers
genutzt wurde, wird das Zielelement in einem zusätzlichen Parameter an da Callback übergeben.


\item[Objektsystem] \hfill \\
Das Objektsystem von Prototype bietet Klassen, Vererbung und Mixins, wobei eine Klasse beliebig
viele Mixins aber nur eine Parentklasse besitzen kann. Eine neue Klasse erstellt man, indem man den
Rückgabewert der Funktion \lstinline{Class.create([superclass][, methods...])} einer Variable
zuweist - es handelt sich dabei um die Konstruktorfunktion der neuen Klasse. Sofern man von einer
anderen Klasse erben möchte, übergibt man diese Klasse als erstes Argument. Alle weiteren Argumente
sind JavaScript-Objekte, die Funktionen enthalten. Diese werden der neuen Klasse hinzugefügt, wobei
bereits vorhandene Methoden überschrieben werden - wenn man Mixins benutzt, sollte man diese also
vor dem Objekt übergeben, welches die neuen Funktionen der Klassen enthält. Beim Überschreiben von
Methoden der Parentklasse nutzt Prototype den dynamischen Character von JavaScript voll aus: Sofern
das erste Argument der neuen Methode den Namen \lstinline{$super} hat, zeigt dieses auf die
überschriebene Methode, sodass sie einfach und ohne zusätzlichen Code aufgerufen werden kann.


\item[Hilfsfunktionen] \hfill \\
Prototype stellt keine globalen Hilfsfunktionen zur Verfügung, allerdings erweitert es die
Prototypen und Konstruktoren bestehender Objekte, sodass über diese Objekte auf die die zahlreichen
Hilfsfunktionen von Prototype zugegriffen werden kann.

\item[UI-Elemente] \hfill \\
Prototype enthält keine UI-Widgets, allerdings wird es oftmals zusammen mit
Scriptaculous\footnote{\href{http://script.aculo.us}{http://script.aculo.us}} verwendet wird. Diese
Erweiterung erlaubt Drag\&Drop von Elementen, sortierbare Listen, Autovervollständigung von
Textfeldern, Inline-Editierung von Texten/Werten und ein \emph{Slider}-Widget zur Auswahl eines
numerischen Werts.

\item[Kompatibilität] \hfill \\
Prototype wird bereits in einigen Teilen von Indico genutzt, daher ist es an sich mit dem übrigen
Code von Indico kompatibel, obwohl sowohl Indico als auch Prototype einige
\lstinline{$X}-Funktionen nutzen, wobei \lstinline{$A} sogar in beiden Frameworks definiert wird -
allerdings überschreibt die \lstinline{$A}-Funktion von Indico die aus Prototype, wobei es keine
Konflikte gibt, da beide Funktionen denselben Zweck haben und auch von den Parametern her
identisch sind. Neben diesem Konflikt gibt keien weiteren Probleme, obwohl Prototype sehr invasiv
ist: Wie auch das Indico-Framework definiert es mehrere globale Objekte mit \enquote{Standardnamen}
wie \emph{Event} oder \emph{Element}. Darüberhinaus erweitert es die Prototypen sowohl von nativen
Objekten wie \lstinline{Array}, \lstinline{Number} und \lstinline{String} - jedoch nicht den
\lstinline{Object}-Prototypen, da Veränderungen an diesem mit hoher Wahrscheinlichkeit Probleme
verursachen; beispielsweise verändert sich das Verhalten von \lstinline{for(var elem in object)}
dadurch - als auch von Hostobjekten wie \lstinline{HTMLElement}. Gerade letzteres ist aufgrund des
größtenteils undefinierten Verhaltens dieser Objekte riskant.

\item[Sonstige Features] \hfill \\
Die meisten Methoden von Prototype kann man sowohl als Methode als auch als Funktion aufrufen, wobei
bei letzterem das Objekt als Funktionsargument übergeben wird. Prototype enthält selbst keine
Funktionen zur Animation von Elementen, jedoch bietet Scriptaculous entsprechende Funktionalität.

\item[Dokumentation] \hfill \\
Prototype besitzt eine ausführliche Online-Dokumentation. Zu jeder Funktion gibt es neben der
Beschreibung auch ein kurzes Codebeispiel, allerdings sind diese Beispiele statisch und können nicht
ausgeführt werden, ohne den Code manuell in eine HTML-Datei zu kopieren. Der Quellcode von Prototype
ist ausführlich kommentiert und in Module unterteilt, die jedoch im Release in eine einzelne Datei
zusammengefasst sind.

\item[Lizenz] \hfill \\
Prototype steht unter der
MIT-Lizenz\footnote{\href{http://www.opensource.org/licenses/mit-license.php}{http://www.opensource.org/licenses/mit-license.php}}.
\end{description}

Ähnlich wie das Indico-Framework bietet Prototype aus fast jedem Bereich etwas, wobei JSON-RPC und
\emph{Data Binding} nicht unterstützt werden.
Die Erstelung und auch der Zugriff auf DOM-Elemente ist in Prototype deutlich sauberer gelöst als in
Prototype, da nur selten auf native DOM-Eigenschaften und -Methoden zurückgegriffen werden muss und
damit einheitlich Prototype-Code verwendet werden kann statt einer Mischung aus Framework-Funktionen
und nativen Funktionen. Die Eventsysteme von Indico und Prototype sind relativ ähnlich - allerdings
bietet Prototype insbesondere durch das auf das Element zeigende \lstinline{this} mehr Komfort.
Anders als in Indico können bei Prototype keine Klassen als Mixins genutzt werden, sondern nur
Objekte - daher ist es nur schwer möglich, Mehrfachvererbung zu erzeugen - man könnte zwar einem
Mixin eine Funktion geben die man als Konstruktor nutzt, allerdings würden sich diese Funktionen der
einzelnen Mixins überschreiben, sodass neben der Parent-Klasse jeweils nur ein solches Mixin genutzt
werden könnte. Über die \emph{Enumerable}- und \emph{Function}-Funktionen bietet Prototype die auch
in Indico vorhandenen Funktionen zur funktionalen Programmierung, wobei sie bei Prototype als
Instanzmethoden realisiert sind statt mit dem jeweiligen Objekt als Parameter aufgerufen zu werden.
Bei UI-Elementen kann Prototype nicht mit Indico mithalten, da selbst mit Scriptaculous wichtige
Elemente wie Dialogfenster nicht unterstützt werden. Deutlich punkten kann Prototype bei der
Dokumentation - das ist dank der minimalen Dokumentation des Indico-Frameworks aber nicht schwierig.
Die MIT-Lizenz, die Prototype nutzt, ist mit der GPL kompatibel, sodass es lizenztechnisch keine
Konflikte gibt.




\section{jQuery}
jQuery ist eine leichtgewichtiges JavaScript-Bibliothek, die auf komfortablen DOM-Zugriff und AJAX
spezialisiert ist. Dabei wird insbesondere das \emph{Chaining} von Methoden genutzt, d.h. die
meisten Methoden geben das aktuelle Objekt zurück, sodass Aufrufketten wie \lstinline{obj.m1().m2()}
möglich sind. Auf der Website \href{http://jquery.com}{http://jquery.com} wird jQuery auch als
\enquote{designed to change the way that you write JavaScript} bezeichnet. Mit einer einzigen, ca.
30 KB (minimiert und \emph{gzip}-komprimiert) großen Datei ist jQuery sehr kompakt.

\begin{description}
\item[DOM-Zugriff] \hfill \\
In jQuery findet der Zugriff auf das DOM über die \lstinline{$(...)}-Funktion statt. Sofern man als
Parameter einen CSS-Selektor übergibt, werden alle durch diesen Selektor ausgewählten Element in
einem neuen jQuery-Objekt verpackt und dieses wird zurückgegeben. Optional kann als zusätzlicher
Parameter der Kontext in Form eines DOM-Elements, DOM-Dokuments oder jQuery-Objekts angegeben
werden, um ausgehend von diesem Element zu suchen. Statt eines Selektors kann man auch ein
DOM-Element oder ein Array solcher Elemente übergeben, um aus selbigen ein neues jQuery-Objekt zu
erzeugen. Wenn man \lstinline{$()} ohne Parameter aufruft, wird ein leeres jQuery-Objekt erstellt.

Um an in einem jQuery-Objekt enhaltene DOM-Objekte zu kommen, kann man die Arraysyntax
\lstinline{obj[index]} nutzen, um das das jeweilige Element zu erhalten. Alternativ kann man auch
mit der \lstinline{get([index])}-Methode nutzen. Sofern ein Index angegeben wird, gibt sie das
jeweilige Element zurück, ansonsten ein Array aller im jQuery-Objekt enthaltenen Elemente.

jQuery nutzt \emph{Sizzle} zur Suche von Elementen anhand eines CSS-Selektors.

\item[DOM-Manipulation] \hfill \\
Zum Erstellen neuer Elemente nutzt man in jQuery ebenfalls die \lstinline{$}-Funktion, indem man den
gewünschten HTML-Code - dabei kann es sich sowohl um ein einzelnes Tag als auch eine beliebig
komplexe HTML-Struktur handeln - als Parameter übergibt. Als zusätzlichen Parameter kann man
entweder ein DOM-Dokument angeben, in dem die Elemente erstellt werden solle, oder aber ein Objekt,
welches die Attribute, die dem neuen Element zugewiesen werden sollen, als Strings enthält.

Bei der Verwendung von jQuery ist es eigentlich niemals notwendig, direkt auf DOM-Elemente
zuzugreifen, da sowohl der Zugriff auf die Attribute eines Elements mittels
\lstinline{attr(name[, value])} als auch der Zugriff auf seine Eigenschaften mittels
\lstinline{prop(name[, value])} möglich ist.
Elementspezifische CSS-Eigenschaften lassen sich durch die \lstinline{css()}-Methode hinzufügen bzw.
ändern. Diese akzeptiert entweder Eigenschaft und Wert in separaten Parametern oder aber ein Objekt,
welches mehrere Eigenschaften und Werte enthält. Dabei kann der Name sowohl in der CSS-Schreibweise
\emph{words-with-dashes} (z.B. \lstinline{background-color}) als auch in der DOM-Schreibweise
\emph{lowerCamelCase} (z.b. \lstinline{backgroundColor} angegeben werden. Bei numerischen
Eigenschaften kann anstelle eines absoluten Werts auch ein Offset in der Form \lstinline{+=number}
angegeben werden, um \emph{number} zum aktuellen Wert zu addieren.

Für häufig genutzte Manipulationen wie dem Ein- und Ausblenden von Elementen stellt jQuery
komfortabel nutzbare Funktionen zur Verfügung, sodass man dabei Entwicklungszeit einspart. Die
Funktionen \lstinline{hide()} und \lstinline{show()} akzeptieren einen optionalen
\emph{duration}-Parameter, der aus dem sofortigen Aus- und Einblenden eine Animation macht.
Alternativ können Elemente auch mit den \emph{slide}-Funktionen ein- und ausgelbendet werden, wobei
sie dabei am oberen Rand der Seite hinaus- bzw. hineinbewegt werden.

Zur Veränderung der Struktur des DOM-Trees - also dem Einfügen, Entfernen und umsortieren von
Elementen - bietet jQuery viele Funktionen, die eigentlich alle sinnvolle Möglichkeiten abdecken.
Neben der inzwischen relativ verbreiteten \lstinline{wrap()}-Funktion enthält jQuery mit
\lstinline{unwrap()} auch das genaue Gegenteil dieser Funktion, d.h. das Entfernen des
Parent-Elements eines Elements und dem Einfügen selbigens an dieser Stelle. Das Einfügen von
Elementen kann in beide Richtungen geschehen: zusätzlich zu Methoden wie \lstinline{append(elem)},
die das übergebene Element in das im jQuery-Objekt enthaltene Element einfügen existieren mit
Methoden wie \lstinline{appendTo(elem)} Methoden, die das im jQuery-Objekt enthaltene Element in das
übergebene Element einfügen. Der komplette Inhalt von Elementen lässt sich durch die Methode
\lstinline{empty()} löschen; beim Ersetzen durch neuen Inhalt gibt es mit \lstinline{html()} und
\lstinline{text()} sowohl die Möglichkeit, HTML einzufügen, als auch einen String als Plaintext
einzufügen, sodass möglicherweise enthaltener HTML-Code nicht ausgeführt wid.

Wenn ein jQuery-Objekt mehrere Element enthält, hängt das Verhalten von der aufgerufenen Funktion
ab. Sofern es möglich und sinnvoll ist, wirkt sich die Funktion aus jedes Element aus. Bei anderen
Operationen wie beispielsweise dem lesenden Zugriff mittels \lstinline{attr()} wird ausschließlich
auf das erste Element zugegriffen.

\item[DOM Traversal] \hfill \\
Wie bereits zuvor erwähnt, kann der \lstinline{$}-Funktion ein Kontext übergeben werden, um
ausgehend von einem Element anhand eines Selektors andere Elemente zu suchen. Neben dieser
Möglichkeit bietet jQuery diverse Methoden um Elemente ausgehend von einem Element auszuwählen -
alle dieser Methoden akzeptieren einen CSS-Selektor zum Filtern der gefundenen Elemente. Neben den
Geschwisterelementen, wobei diese auf Elemenet vor bzw. nach dem aktuellen Element eingeschränkt
werden können, können mit diesen Methoden auch die Parent-Elemente selektiert werden, wobei dort je
nach Funktion das direkte Parent-Element, alle Parent-Elemente oder alle Parent-Elemente bis zu
einem bestimmten Element zurückgegeben werden. Mit \lstinline{closest(selector)} bietet jQuery eine
Komfortmethode, um sich ausgehend vom aktuellen Element im DOM-Tree nach oben durchzuarbeiten, bis
das gewünschte Element gefunden wurde - dabei kann es sich auch um das aktuelle element selbst
handeln.

Der Inhalt von jQuery-Objekten lässt sich darüberhinaus filtern und erweitern: man kann die
Elementliste anhand eines CSS-Selektors filtern, bestimmte Elemente entfernen, die vor einer
Suche enthaltenen Elemente der Elementliste wieder hinzufügen und einzelne Elemente hinzufügen. Auch
das Reduzieren eines jQuery-Objekts auf ein einzelnes Element ist möglich - dabei kann es
beispielsweise sich um das Element mit einem bestimmten Index oder um das erste bzw. letzte Element
handeln.

Eine sehr spezielle, aber für die absolute Positionierung von Elementen sehr nützliche Methode ist
\lstinline{offsetParent()}. Diese sucht das erste übergeordnete Element, welches positioniert ist
und damit das Referenzelement für die absolute Positionierung ist.

\item[Events] \hfill \\
jQuery bietet verschiedene Möglichkeiten, Eventhandler zu registrieren. Der einfachste und
komfortabelste Weg ist, die dem Eventnamen entsprechende Methode eines jQuery-Objekts aufzurufen und
dieser die Handlerfunktion als Parameter zu übergeben. Eine weitere Möglichkeit ist über die
\lstinline{bind()}-Methode; dabei übergibt man Eventname und -handler als separate Parameter oder in
einem Objekt, welches mehrere Eventhandler enthalten kann. Um dieselbe Funktion für mehrere Events
zu benutzen können die jeweiligen Eventnamen mit Leerzeichen getrennt angegeben werden. Der große
Vorteil bei der Benutzung von \lstinline{bind()} ist jedoch, dass man die Events in Namespaces
unterteilen kann indem man \lstinline{'eventname.something'} als Eventname verwendet. Dies hat den
Vorteil dass man diese Events separat auslösen oder entfernen kann, ohne andere Events dasselben
Typs auszulösen oder zu entfernen. Darüberhinaus kann man mit dieser Funktion beliebige Events
erstellen, d.h. nicht nur die standardmäßig unterstützen DOM-Events. Neben den regulären DOM-Events
unterstützt jQuery die Internet Explorer-spezifischen Events \emph{mouseenter} und
\emph{mouseleave}, welche logischerweise emuliert werden, wenn sie nicht vom Browser unterstützt
werden.

Mit \lstinline{delegate(selector, eventType, handler)} erlaubt jQuery die Delegation von Events an
ein übergeordnetes Element. Dies hat den Vorteil, dass nicht alle von \lstinline{selector}
ausgewählte Elemente bereits zum Zeitpunkt der Eventhandler-Registrierung existieren müssen und
beispielsweise bei einer Liste mit vielen Elementen nur ein einziger Eventhandler registriert werden
muss, was die Performance erhöht. Sofern man kein Basis-Element kennt, sondern Events von Elementen
an einer \emph{beliebigen} Position im Dokument verarbeiten möchte, kann man die
\lstinline{live}-Methode nutzen; ihre Parameter sind mit denen von \lstinline{bind()} identisch.
Intern erstellt diese Methode einfach ein \emph{Delegate} mit dem Dokument selbst als Basis-Element.
Der Nachteil dieser Art der Eventverarbeitung ist jedoch, dass das Element bis zum Basis-Element
aufsteigt und erst dort ein weiteres Aufsteigen verhindert werden kann.

Zum Löschen von Eventhandlern bietet jQuery mit \lstinline{unbind()}, \lstinline{die()} und
\lstinline{undelegate()} Funktionen für die verschiedenen Eventhandlertypen. Dabei entsprechen die
Parameter der Funktionen ihren Gegenstücken, wobei die Handlerfunktion jeweils optional ist, sodass
man auch alle Events eines Typs löschen kann. Zusätzlich zu diesen Parametern kann man bei
\lstinline{unbind()} und \lstinline{undelegate()} auch \lstinline{'.namespace'} angeben, um alle
Events aus dem angegebenen Namespace zu löschen.

Um Events manuell auszulösen bietet jQuery genau wie bei der regulären Registrierung von
Eventhandlern zwei Möglichkeiten. Zum einen kann man die Shortcut-Methode die dem Eventnamen
entspricht ohne Parameter aufrufen, zum anderen kann man die Methode
\lstinline{trigger(eventType[, params])} nutzen. Diese erlaubt nebem der Möglichkeit, einen Namespace
anzugeben, die Übergabe weiterer Parameter an den Eventhandler. Durch \lstinline{trigger()}
ausgelöste Events verhalten sich wie durch Benutzerinteraktion ausgelöste Events; sie steigen im
DOM-Tree auf und lösen die Standardaktion des Browsers aus (beispielsweise das Laden einer neuen
Seite). Wenn dieses Verhalten nicht erwünscht ist, bietet die Funktion \lstinline{triggerHandler()}
die Möglichkeit, nur per jQuery registrierte Eventhandler auszulösen und den Rückgabewert des
letzten Handlers dieses Events zu verarbeiten.

An die Eventhandler-Funktionen übergibt jQuery jeweils ein Event-Objekt und falls das Event manuell
ausgelöst wurde und zusätzliche Parameter übergeben wurden ebendiese. Beim Event-Objekt handelt es
sich um ein von jQuery erstelltes Objekt, in welches die Eigenschaften des ursprünglichen
Event-Objekts kopiert wurden. Dabei stellt jQuery sicher, dass browserspezifische Eigenschaften wie
der gedrückten Taste bei einem Tastatur-Event oder der Mausposition bei einem Maus-Event
normalisiert werden und immer über dieselben Eigenschaften verfügbar sind. Darüberhinaus enthält das
Event-Objekt browserunabhändige Methoden, um die weitere Verarbeitung des Events zu beeinflussen und
beispielsweise das Ausführen der Standardaktion zu verhindern.

\begin{lstlisting}[caption=Blockieren des Click-Events einiger Links via jQuery]
$('a.do-not-click').click(function(e) {
    e.preventDefault();
});
\end{lstlisting}

\item[Objektsystem] \hfill \\
jQuery enthält kein Objektsystem.

\item[Hilfsfunktionen] \hfill \\
jQuery bietet eine Vielzahl an Funktionen, die jeweils über \lstinline{$.funcName} verfügbar sind.
Neben den üblichen funktionalen Funktionen wie \lstinline{map()} und \lstinline{each} bietet jQuery
auch Funktionen, um eine Variable auf einen bestimmten Typ zu testen und mit \lstinline{trim()} auch
eine Funktion, um Whitespace am Anfang oder Ende eines Strings zu entfernen. Auch ein JSON-Parser
ist enthalten - dieser wird jedoch nur genutzt, wenn der verwendete Browser JSON nicht nativ
unterstützt.

Mit \lstinline{$.browser} besitzt jQuery ein Objekt, welches Informationen zum verwendeten Browser
und dessen Version enthält. Dieses ist jedoch als \emph{deprecated} markiert, da es im Falle von
browserspezifischen Problemen und Features sinnvoller ist, auf das Vorhandensein ebendieser zu
prüfen. Dazu besitzt jQuery das \lstinline{$.support}-Objekt. Es enthält Informationen zu allen
Browserfeatures, die jQuery selbst benötigt - die Tests, ob die jeweiligen Features vorhanden sind
müssen beim Laden jeder Seite ausgeführt werden, weshalb die Anzahl möglichst gering gehalten wird.

\item[UI-Elemente] \hfill \\
jQuery selbst enthält keinerlei Widgets, allerdings existiert mit \emph{jQuery
UI}\footnote{\href{http://jqueryui.com}{http://jqueryui.com}} eine Erweiterung, die diverse Widgets
und UI-bezogene Features wie Drag\&Drop und vergrößer- und verkleinerbare, auswählbare und
sortierbare Elemente enthält. Die Widgets bieten Dialogfenster, Buttons, Kalender,
Fortschrittsbalken, Tabs und Slider. Neben diesen Standardwidgets gibt es noch ein
\emph{Accordion}-Widget, welches ein \enquote{Akkordion}-Menü bzw. -Panel ermöglicht. Ebenfalls
enthalten ist ein \emph{Autocomplete}-Widget, um HTML-Textfelder mit Autovervollständigung zu
versehen.

\imga{jquery-ui-calendar.png}{Der jQuery UI Datepicker}{jQuery UI-Datepicker}

Erwähnenswert ist ist einfache Anpassbarkeit der jQuery UI-Widgets - mit dem
\emph{ThemeRoller}\footnote{\href{http://jqueryui.com/themeroller/}{http://jqueryui.com/themeroller/}}
gibt es eine Webapplikation, über die man mit wenigen Klicks ein neues Farbtheme für alle Widgets
zusammenstellen kann und auch direkt sieht, wie die Widgets mit dem neuen Theme aussehen. Neben den
Farben lassen sich auch viele weitere Aspekte per CSS anpassen - entweder global für alle Widgets
oder über die widgetspezifischen CSS-Klassen \lstinline{.ui-<widgetname>} nur für einzelne Widgets.

Codeseitig erweitert jedes Widget das jQuery-Objekt um eine Methode, über die das Widget sowohl
erstellt als auch verändert oder wieder entfernt werden kann. Wenn die Methode ohne Parameter
aufgerufen wird, erstellt sie das Widget mit Standardeinstellungen; alternativ kann auch ein Objekt
als Parameter übergeben werden, um eigene Einstellungen zu benutzen. Für alle anderen Operationen
übergibt man dieser Methode als ersten Parameter den Funktionsnamen und in den weiteren Parametern
die funktionsspezifischen Parameter, beispielsweise \lstinline{dialog('open')} um einen zuvor
erstellten Dialog zu öffnen.

\item[Kompatibilität] \hfill \\
jQuery exportiert nur zwei globale Funktionen: \lstinline{jQuery} und \lstinline{$}, wobei es
sich bei letzterer um einen Alias für \lstinline{jQuery} handelt. Falls \lstinline{$} bereits
anderweitig verwendet wird, kann man die \lstinline{jQuery.noConflict()}-Funktion nutzen, um das
ursprünliche \lstinline{$} wiederherzustellen. Um trotzdem nicht immer \lstinline{jQuery} statt
\lstinline{$} schreiben zu müssen, kann man seinen Code einfach in eine Funktion wrappen, die
\lstinline{$} als Parameter zur Verfügung stellt.
\begin{lstlisting}[caption=Verwendung von \$.noConflict]
jQuery.noConflict();
(function($) {
    // $ === jQuery
})(jQuery);
\end{lstlisting}

\item[Sonstige Features] \hfill \\
Wie bereits in der einführenden Beschreibung erwähnt macht jQuery extensiven Gebrauch vom
\emph{Method Chaining}. Dies erspart dem Programmierer Arbeit, da er viele Methoden auf ein Objekt
anwenden kann ohne den Objektnamen für jeden Aufruf neu schreiben zu müssen. Ebenfalls erhöht es die
Performance, da nur einmal ein \emph{variable lookup} für die Objektvariable notwendig ist. Bei
Methoden, die sowohl Getter als auch Setter sein können, ist allerdings nur die Setter-Variante
\emph{chainable}, da der Getter einen Wert zurückgeben muss, der nicht dem ursprünglichen Objekt
entspricht. Ein weiteres Feature in diesen Bereich ist die interne Verkettung von jQuery-Objekten.
Wenn ein jQuery-Objekt, welches Element enthält, gefiltert wird oder Elemente hinzugefügt werden,
wird intern ein neues Objekt erstellt, sodass die alte Elementliste erhalten bleibt. Mit der
\lstinline{end()}-Methode kann man in der Aufrufkette zum vorherigen Objekt zurückspringen.
Allerdings ist dabei zu beachten, dass der Code lesbar und verständlich bleibt - teilweise ist es
sinnvoll, eine neue Aufrufkette zu beginnen statt stur zu versuchen, möglichst viele Aktionen
innerhalb derselben Kette auszuführen.

Die meisten Funktionen in jQuery, die Werte verändern, akzeptieren statt eines Werts auch eine
Funktion. Diese wird durch jQuery mit dem Index des Elements innerhalb des jQuery-Objekts und dem
aktuellen Wert als Parameter aufgerufen und der Rückgabewert wird als Wert benutzt, sofern er nicht
\lstinline{undefined} ist. Innerhalb dieser Funktion zeigt \lstinline{this} auf das jeweilige
DOM-Element.

Ein anderes Feature von jQuery ist das \lstinline{Deferred}-Objekt. Es ermöglicht die Registrierung
von Callbacks, wobei diese in drei verschiedenen Kategorien registriert werden können: \emph{done},
\emph{fail} und \emph{always}. Das Deferred-Objekt kann entweder \emph{fail} oder \emph{done} zu
einer beliebigen Zeit auslösen - es gilt dann als \emph{resolved}. Nach dem Ausführen der Callbacks
werden automatisch die \emph{always}-Callbacks aufgerufen. Sobald das Objekt \emph{resolved} ist
kann sich sein Status nicht mehr ändern, d.h. es ist ausgeschlossen dass sowohl die
\emph{fail}-Callbacks als auch die \emph{done}-Callbacks ausgeführt werden. Der große Vorteil des
Deferred-Objekts ist, dass Callbacks auch registriert werden können, wenn das Objekt bereits
\emph{resolved} ist - die entsprechende Callbackfunktion wird in diesem Fall sofort ausgeführt.
Da externer Code oftmals nur die Möglichkeit haben soll, Callbacks zu registrieren, diese aber nicht
selbst auslösen können soll, bietet das Deferred-Objekt mit der \lstinline{promise()}-Methode eine
Möglichkeit, nur die entsprechenden Methoden zurückzugeben, sodass das Deferred-Objekt selbst
niemals den Sichtbarkeitsbereich der erstellenden Funktion verlassen muss. Diese Funktionalität wird
beispielsweise von den AJAX-Funktionen von jQuery genutzt; sie geben ein solches
\emph{Promise}-Objekt zurück.

jQuery kann einfach mit eigenen Funktionen erweitert werden. Über \lstinline{jQuery.fn} kann auf den
Prototypen der jQuery-Objekte zugegriffen werden sodass man diesem einfach eine eigene Funktion
hinzufügen kann. Um jQuery uanbhängig von einem bestimmten jQuery-Objekt zu erweitern -
beispielsweise um eine Funktion hinzuzufügen, die keine HTML-Elemente verwendet - kann man eine
Funktion auch direkt dem globalen \lstinline{jQuery}-Objekt hinzufügen.

\item[Dokumentation] \hfill \\
jQuery besitzt eine ausführliche Online-Dokumentatino, die nach Aufgabenbereichen wie
\emph{Events}, \emph{Traversing}, \emph{Manipulation} und \emph{forms} gegliedert ist. Jede
Funktionsbeschreibung besitzt mindestens ein Codebeispiel; wenn eine Funktion je nach Parameter
unterschiedliche Aktionen ausführt, gibt es für jede Funktionalität ein eigenes Beispiel. Diese
Beispiele werden meist beim Laden der Seite automatisch ausgeführt, sodass man direkt sieht, wie
sich eine Funktion auswirkt. Bei einigen Funktionen wie beispielsweise Animationen und Effekten muss
der Beispielcode durch einen Klick explizit ausgeführt werden - dies macht Sinn, da bei solchen
Funktionen nicht der Endzustand interessant ist sondern der Übergang. Die komplette Dokumentation
kann inklusive Beispielcode auch als XML-Datei heruntergeladen werden, sodass man sie beispielsweise
in einer IDE, die das Format unterstützt, importieren könnte.

Während die Produktivversion von jQuery minimiert ist, kann man auf der jQuery-Website eine lesbare
Entwicklungsversion herunterladen. Dabei handelt es sich um eine ca. 230 KB große JavaScript-Datei
die von der Funktionalität her mit der Produktiversion identisch ist. Sofern man lieber einzelne,
nach Aufgabenbereich unterteilte, Dateien möchte, kann man sich auch den \enquote{Quellcode} auf der
GitHub-Seite\footnote{\href{https://github.com/jquery/jquery}{https://github.com/jquery/jquery}} von
jQuery herunterladen. Unabhängig davon welche Entwicklungsversion man herunterlädt ist der
enthaltene Code kommentiert, wobei es sich bei den Kommentaren strikt um technikbezogene Hinweise
handelt - ale Dokumentation sind diese nicht brauchbar, was dank der Onlinedokumentation aber auch
nicht notwendig ist.

\item[Lizenz] \hfill \\
jQuery ist sowohl unter der MIT-Lizenz als auch der GPL verfügbar; jeder Entwickler hat die
Möglichkeit die Lizenz zu nutzen, die besser zu seiner Software bzw. dessen Lizenz passt.
\end{description}

\imga{jquery-ui-accordion.png}{Das Akkordion-Menü von jQuery UI}{jQuery UI-Akkordion}

jQuery ist auf DOM-Operationen und AJAX spezialisiert, wobei letzteres allgemein gehalten ist,
sodass JSON-RPC selbst implementiert werden müsste. Der Zugriff auf DOM-Elemente ist in jQuery
deutlich komfortabler als in Indico, da man durch die Nutzung von CSS-Selektoren flexibler ist und
es oftmals nicht notwendig ist, automatisch generierte IDs zu vergeben, um ein Element später noch
referenzieren zu können - in jQuery nutzt man die Methoden zum Durchsuchen des DOM-Trees um
beispielsweise ausgehend vom angeklickten Element die dazugehörige Tabellenzeile zu finden. Beim
Verändern von Elementen führt jQuery ebenfalls: die Möglichkeit, Objekte und Funktionen als Wert zu
nutzen erhöht die Flexibilität extrem und auch die große Menge an Funktionen zum Verändern der
DOM-Struktur ist beim Erzeugen dynamischer Elemente wie Formularen in Dialogfenstern und deren
Validierung nützlich. Das Eventsystem von jQuery ist dank der Namespaces sehr flexibel und das
vollständig normalisierte Event-Objekt vereinfacht die browserunabhängige Entwicklung. Ein Nachteil,
der durch das \emph{Method Chaining} aber unumgänglich ist, ist das Fehlen eines
Eventhandler-Objekts, welches eine komfortable Möglichkeit bietet, das Event wieder zu löschen. Man
kann eine solche Funktion aber leicht selbst erstellen, indem man beim Registrieren des Events
Eventname und Funktion in einer Closure speichert und damit den entsprechenden Eventhandler löscht.
Ein Objektsystem ist in jQuery nicht vorhanden - daher müsste dort auf das bestehende System oder
eine separate Bibliothek zurückgegriffen werden. Genau wie das Indico-Framework unterstützt auch
jQuery Standardmethoden zur funktionalen Programmierung, wobei nicht alle in Indico verwendeten
Funktionen auch in jQuery vorhanden sind. Sowohl Indico als auch jQuery enthalten ein UI-Framework,
wobei sie sich in einigen grundlegenden Aspekten unterscheiden: Die Widgets von Indico sind darauf
ausgelegt, sowohl Struktur als auch Inhalt selbst zu generieren, während jQuery UI dazu gedacht ist,
bestehenden HTML-Code zu erweitern - letzteres hat den Vorteil, dass auch ohne JavaScript eine
gewisse Grundfunktionalität vorhanden ist, in Indico derzeit nicht der Fall ist und auch nicht
vorgesehen ist. Abgesehen von diesem Nachteil enthält jQuery UI mit den Widgets \emph{Dialog} und
\emph{Tabs} die beiden Widgets, die für Indico am wichtigsten sind - das in Indico vorhandene
Dialog-Widget hat insbesondere beim Anzeigen modaler Dialogfenster einige Probleme. Ein weiterer
Pluspunkt für jQuery bzw. jQuery UI ist die Anpassbarkeit der Widgets - da das Design von Indico
schlicht und seriös ist, sollten die Widgets nicht durch bunte Balken hervortreten sondern sich
sauber in das Design integrieren. Durch die widgetübergreifenden CSS-Klassen wäre dies problemlos
möglich. Da Prototype derzeit auf einigen Seiten vno Indico integriert wird, steht dessen
\lstinline{$}-Funktion mit der gleichnamigen Funktion aus jQuery im Konflikt. Indico nutzt derzeit
an einigen Stellen \emph{Preloader}-Mixins, die zuerst einen oder mehrere AJAX-Requests ausführen
und danach das Objekt selbst initialisieren. Dabei könnte das \emph{Deferred}-Objekt von jQuery
nützlich sein. \emph{Data Binding} wird von jQuery nicht unterstützt. Die ausführliche Dokumentation
von jQuery ermöglicht es insbesondere auch neuen Entwicklern, sich schnell einzuarbeiten, während
man beim JavaScript-Framework von Indico viel vorhandenen Code studieren muss um sich mit seinen
Funktionen vertraut zu machen. Beide Lizenzen von jQuery sind mit für die Nutzung in Indico
geeignet.






\section{Classy}
Bei Classy handelt es sich um eine JavaScript-Bibliothek, um Klassen zu implementieren. Dabei
orientiert sie sich am Objektmodell von Python. Classy kann von
\href{http://classy.pocoo.org/}{http://classy.pocoo.org/} heruntergeladen werden.

\begin{description}
\item[DOM-Funktionen] \hfill \\
Da Classy eine auf auf Klassen/Objekte spezialisierte Bibliothek ist, bietet sie keinerlei
DOM-Funktionen.

\item[Objektsystem] \hfill \\
Das Objektmodell von Classy orientiert sich an dem der Scriptsprache Python. Jede Klasse erbt von
einer Basisklasse - in Python ist das (bei \emph{new-style}-Klassen)
\lstinline[language=Python]{object}, in Classy ist es \lstinline{Class}. Um eine neue Klasse zu
definieren, erstellt man also eine neue Klasse, die von \lstinline{Class} erbt, indem man deren
statische Methode \lstinline{$extend(props)} aufruft, wobei \lstinline{props} ein Objekt ist,
welches die neue Klasse definiert: die Methode \lstinline{__init__()} wird zum Konstruktor der neuen
Klasse, alle weiteren Methoden werden zu Instanzmethoden der Klasse.

Um einer Klasse Mixins hinzuzufügen, definiert man beim Erstellen der Klasse ein Array
\lstinline{__include__}, welches die Mixins enthält - dabei handelt es sich um JavaScript-Objekte,
die Funktionen enthalten. Ein weiteres optionales Objekt, welches man beim Erstellen der Klasse
übergeben kann, ist \lstinline{__classvars__}. Die darin gespeicherten Werte sind innerhalb der
Klasse über \lstinline{this.$class.<name>} verfügbar und nicht instanzspezifisch.

Sofern beim Erstellen einer Klasse eine Methode der Parent-Klasse überschrieben wurde, ist diese
Methode in \lstinline{this.$super} verfügbar, sodass sie komfortabel aufgerufen werden kann.

Genau wie in Python ist auch bei Classy der \lstinline{new}-Operator optional. Dies wird dadurch
erreicht, dass in der Konstruktorfunktion überprüft wird, ob \lstinline{this === window} ist. Falls
dem so ist, erstellt die Funktion ein neues Objekt und gibt dieses zurück.

\item[Hilfsfunktionen] \hfill \\
Classy bietet neben dem Objektsystem keine weitere Funktionalität.

\item[Kompatibilität] \hfill \\
Classy exportiert ein globales Objekt \lstinline{Class}. Sofern dieser Name mit einem bestehenden
Objekt kollidiert, kann die ursprüngliche Zuweisung mit \lstinline{Class.$noConflict()}
wiederhergestellt werden und der Rückgabewert dieser Funktion entweder einer anderen Variable
zugewiesen oder als Parameter einer anonymen Funktion genutzt werden, um innerhalb dieser
\lstinline{Class} benutzen zu können.

\item[Dokumentation] \hfill \\
Classy besitzt eine Onlinedokumentation, in der die Benutzung anhand von Beispielen beschrieben
wird und jede Funktion dokumentiert ist. Der Quellcode ist an Stellen, wo es zum Verständnis
notwendig ist, kommentiert.

\item[Lizenz] \hfill \\
Classy steht unter der
BSD-Lizenz\footnote{\href{http://www.opensource.org/licenses/BSD-3-Clause}{http://www.opensource.org/licenses/BSD-3-Clause}}.
\end{description}

Classy implementiert ausschließlich ein Klassensystem, weshalb auch nur dieser Bereich mit Indico
verglichen werden kann. Sowohl Indico als auch Classy ermöglichen die Definition von Klassen und das
Erben von einer anderen Klasse. Classy hat dabei den Vorteil, dass überschriebene Methoden
komfortable aufgerufen werden können, ohne den Namen der ursprünglichen Klasse im Aufruf verwenden
zu müssen. Dies bedeutet aber gleichzeitig, dass man jeweils nur eine gleichnamige Parent-Methode
aufrufen kann, was in Classy aber kein Problem ist, da es keine Mehrfachvererbung unterstützt
sondern nur eine Parent-Klasse und mehrere Mixins, die ausschließlich Funktionen enthalten - dabei
überschreiben gleichnamige Funktionen innerhalb von Mixins die vorherige Funktion. Dadurch, dass
Classy zwischen Mixins und der Parent-Klasse unterscheidet, ist keine echte Mehrfachvererbung
möglich - der manuelle Aufruf einer als Konstruktor verwendeten Funktion ist problematisch, da jedes
Mixin einen einzigartigen Namen für diese Funktion benutzen müsste. Allerdings wäre es durchaus
möglich, diese Funktion genau wie das Mixin zu nennen, sodass der Unterschied zum Indico-Code, wo
der Konstruktor einer Parentklasse mittels \lstinline{this.NameOfTheClass()} aufgerufen wird, nicht
so gravierend wäre. Der große Nachteil gegenüber dem Objektsystem von Indico besteht jedoch darin,
dass Mixins nicht eigenständig benutzt werden können - sie sind reine Sammlungen von Funktionen.
Kompatibilitätsprobleme zwischen Indico und Classy bestehen nicht, da der Name \lstinline{Class}
nirgends verwendet wird. Classy ist deutlich besser dokumentiert als das Objektsystem von Indico,
allerdings gibt es aufgrund der starken Nutzung von Klassen in Indico extrem viele Codebeispiele des
aktuellen Objektsystems. Die BSD-Lizenz ist mit der von Indico genuzten GPL kompatibel.




\section{Underscore.js}
Underscore.js ist eine insbesonders auf funktionale Programmierung ausgerichtete
JavaScript-Bibliothek. Sie hat zum Ziel möglichst viele Hilfsmittel anzubieten und dabei sowohl die
funktionale  Programmierung zu vereinfachen als auch \emph{Method Chaining} zu ermöglichen. \\
Underscore.js kann auf der Website
\href{http://documentcloud.github.com/underscore/}{http://documentcloud.github.com/underscore/}
heruntergeladen werden.

\begin{description}
\item[DOM-Funktionen] \hfill \\
Underscore.js ist eine auf funktionale Programmierung ausgerichtete Bibliothek. Da sie explizit als
\enquote{tie to go along with jQuery} bezeichnet wird, enthält sie selbst keine DOM-Funktionen.

\item[Objektsystem] \hfill \\
Underscore.js enthält kein Objektsystem.

\item[Hilfsfunktionen] \hfill \\
Die Funktionen von Underscore.js sind alle über das globale Objekt \lstinline{_} verfügbar, wobei
sie in fünf Kategorien unterteilt sind: \emph{Collections}, \emph{Arrays}, \emph{Functions},
\emph{Objects} und \emph{Utility}.

\emph{Collections} enthält Funktionen, die sowohl mit Arrays als auch mit Objekten arbeiten können.
Dabei handelt es um Standardfunktionen wie \lstinline{filter()}, \lstinline{all()} und
\lstinline{map()} aber auch um Komfortfunktionen wie \lstinline{pluck()}, welche aus einer Liste mit
Objekten jeweils eine bestimmte Eigenschaft extrahiert.

\emph{Arrays} enthält Funktionen, die ausschließlich bei Arrays sinnvoll sind, da sie entweder
sortierte Elemente oder Zugriff über einen fortlaufenden Index voraussetzen. Neben
Standardfunktionen wie \lstinline{indexOf()} und \lstinline{range()} gibt es dort auch Funktionen
zum Verknüpfen oder Vergleichen von Arrays; beispielsweise \lstinline{zip()} und
\lstinline{union()}.

\emph{Functions} enthält Funktionen, die mit Funktionen arbeiten. Während viele dieser Funktionen in
JavaScript-Bibliotheken und -Frameworks üblich sind - beispielsweise \lstinline{bind()} zum Fixieren
von \lstinline{this} und optional auch von Argumenten (\emph{Currying}) - enthält die Kategorie auch
komplexere Funktionen wie \lstinline{memoize()} zum Cachen des Rückgabewerts einer Funktion bei
gleichbleibenden Aufrufparametern oder \lstinline{debounce()} und \lstinline{throttle()} um viele
kurz hintereinander erfolgende Funktionsaufrufe zu reduzieren.

\emph{Objects} enthält Funktionen, die ausschließlich mit Objekten arbeiten. Darunter sind
beispielsweise Funktionen, die bestimmte Elemente (Keys, Werte oder Funktionen) aus einem Objekt
extrahieren und Funktionen, die ein Objekt mit Eigenschaften eines anderen Objekts erweitern.
Ebenfalls enthalten sind \lstinline{is<something>()}-Funktionen, die überprüfen, ob ein Objekt einen
bestimmten Typ hat. Diese nutzen \emph{Duck Typing}, d.h. es wird überprüft ob sich das Objekt wie
ein bestimmter Typ verhält und falls dem so ist wird angenommen, dass es ein Objekt dieses Typs ist.

\emph{Utilities} enthält neben der bereits aus vielen anderen Libraries bekannten
\lstinline{noConflict}-Funktion eine Funktion, um Underscore.js mit eigenen Funktionen zu erweitern,
einen ID-Generator der einzigartige IDs zurückgibt und eine einfache Template-Engine.

Gleichzeitig handelt es sichbei \lstinline{_} auch um eine Funktion, die ein Objekt in einem
Wrapperobjekt einschließt, welches \emph{Chaining} ermöglicht. Eine solche Aufrufkette beginnt in
Underscore.js immer mit \lstinline{_(obj).chain()}. Danach können alle Funktionen aus Underscore.js
als Instanzmethoden des Chain-Objekts aufgerufen werden, wobei der erste Funktionsparameter, der ja
normalerweise das OBjekt wäre, nicht mehr angegeben werden muss. Um am Ende aus dem Chain-Wrapper
wieder ein Array bzw. Objekt zu erhalten, besitzt es die Methode \lstinline{value()}.

\item[Kompatibilität] \hfill \\
Underscore.js exportiert ausschließlich ein globales Objekt \lstinline{_}. Die Chance, dass dieser
Name in bestehendem Code verwendet wird ist zwar relativ hoch, allerdings existiert solch ein
Variablenname in der Regel nur innerhalb von Funktionen, wodurch der Konflikt ignoriert werden kann,
sofern keine Funktionen von Underscore.js innerhalb dieser Funktion genutzt werden sollen. Ein
weiterer häufiger Verwendungszweck des Namens \lstinline{_} für eine Funktion ist bei der
internationalisierung - dort nutzt man oftmals \lstinline{_('something')} um Text zu lokalisieren.
In diesem Fall muss man die \lstinline{_.noConflict()}-Funktion nutzen und Underscore.js unter einem
anderen Namen zugänglich zu machen und die urspröngliche Variable bzw. Funktion wiederherzustellen.

\item[Dokumentation] \hfill \\
Underscore.js enthält eine ausführliche Onlinedokumentation mit einer kurzen Beschreibung und einem
Beispiel für jede Funktion. Die Beispiele sind nicht ausführbar, allerdings sind Ausgabe bzw.
Rückgabewerte des Beispielcodes jeweils angegeben. Neben der Dokumentation existiert auch eine
ausführlich kommentierte Version den Quellcodes, die alle internen Abläufe erklärt.

\item[Lizenz] \hfill \\
Underscore.js steht unter der MIT-Lizenz.
\end{description}
